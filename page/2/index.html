<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="君子性非异也 善假于物也">
<meta property="og:url" content="http://.com/page/2/index.html">
<meta property="og:site_name" content="君子性非异也 善假于物也">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="君子性非异也 善假于物也">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 君子性非异也 善假于物也 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">君子性非异也 善假于物也</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'WEps6UsQK5do8sDRpD_N','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/20/项目管理Git的常用命令/" itemprop="url">
                  项目管理Git常用命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-20T19:32:17+08:00" content="2015-06-20">
              2015-06-20
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="项目管理Git常用命令"><a href="#项目管理Git常用命令" class="headerlink" title="项目管理Git常用命令"></a>项目管理Git常用命令</h1><h3 id="Git是一个很强大的分布式版本控制系统-它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。"><a href="#Git是一个很强大的分布式版本控制系统-它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。" class="headerlink" title="Git是一个很强大的分布式版本控制系统,它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。"></a>Git是一个很强大的分布式版本控制系统,它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。</h3><p>Git常用操作命令：</p>
<p>1) 远程仓库相关命令<br>检出仓库：$ git clone git://github.com/jQuery/jquery.git</p>
<p>查看远程仓库：$ git remote -v</p>
<p>添加远程仓库：$ git remote add [name] [url]</p>
<p>删除远程仓库：$ git remote rm [name]</p>
<p>修改远程仓库：$ git remote set-url –push [name] [newUrl]</p>
<p>拉取远程仓库：$ git pull [remoteName] [localBranchName]</p>
<p>推送远程仓库：$ git push [remoteName] [localBranchName]</p>
<p>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：<br>$git push origin test:master // 提交本地test分支作为远程的master分支<br>$git push origin test:test // 提交本地test分支作为远程的test分支<br>2）分支(branch)操作相关命令<br>查看本地分支：$ git branch</p>
<p>查看远程分支：$ git branch -r</p>
<p>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支</p>
<p>切换分支：$ git checkout [name]</p>
<p>创建新分支并立即切换到新分支：$ git checkout -b [name]</p>
<p>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p>
<p>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并</p>
<p>创建远程分支(本地分支push到远程)：$ git push origin [name]</p>
<p>删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name]</p>
<p>*创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)</p>
<p>$git symbolic-ref HEAD refs/heads/[name]</p>
<p>$rm .git/index</p>
<p>$git clean -fdx<br>3）版本(tag)操作相关命令<br>查看版本：$ git tag</p>
<p>创建版本：$ git tag [name]</p>
<p>删除版本：$ git tag -d [name]</p>
<p>查看远程版本：$ git tag -r</p>
<p>创建远程版本(本地版本push到远程)：$ git push origin [name]</p>
<p>删除远程版本：$ git push origin :refs/tags/[name]</p>
<p>合并远程仓库的tag到本地：$ git pull origin –tags</p>
<p>上传本地tag到远程仓库：$ git push origin –tags</p>
<p>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’<br>4) 子模块(submodule)相关操作命令</p>
<p>添加子模块：$ git submodule add [url] [path]<br>如：$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs</p>
<p>初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行</p>
<p>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下</p>
<p>删除子模块：（分4步走哦）</p>
<p>1) $ git rm –cached [path]</p>
<p>2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</p>
<p>3) 编辑“ .git/config”文件，将子模块的相关配置节点删除掉</p>
<p>4) 手动删除子模块残留的目录</p>
<p>5）忽略一些文件、文件夹不提交<br>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如<br>target<br>bin<br>*.db<br>Git 常用命令</p>
<p>git branch 查看本地所有分支</p>
<p>git status 查看当前状态</p>
<p>git commit 提交</p>
<p>git branch -a 查看所有的分支</p>
<p>git branch -r 查看本地所有分支</p>
<p>git commit -am “init” 提交并且加注释</p>
<p>git remote add origin git@192.168.1.119:ndshow</p>
<p>git push origin master 将文件给推到服务器上</p>
<p>git remote show origin 显示远程库origin里的资源</p>
<p>git push origin master:develop</p>
<p>git push origin master:hb-dev 将本地库与服务器上的库进行关联</p>
<p>git checkout –track origin/dev 切换到远程dev分支</p>
<p>git branch -D master develop 删除本地库develop</p>
<p>git checkout -b dev 建立一个新的本地分支dev</p>
<p>git merge origin/dev 将分支dev与当前分支进行合并</p>
<p>git checkout dev 切换到本地dev分支</p>
<p>git remote show 查看远程库</p>
<p>git add .</p>
<p>git rm 文件名(包括路径) 从git中删除指定文件</p>
<p>git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来</p>
<p>git config –list 看所有用户</p>
<p>git ls-files 看已经被提交的</p>
<p>git rm [file name] 删除一个文件</p>
<p>git commit -a 提交当前repos的所有的改变</p>
<p>git add [file name] 添加一个文件到git index</p>
<p>git commit -v 当你用－v参数的时候可以看commit的差异</p>
<p>git commit -m “This is the message describing the<br>commit” 添加commit信息</p>
<p>git commit -a -a是代表add，把所有的change加到git index里然后再commit</p>
<p>git commit -a -v 一般提交命令</p>
<p>git log 看你commit的日志</p>
<p>git diff 查看尚未暂存的更新</p>
<p>git rm a.a 移除文件(从暂存区和工作区中删除)</p>
<p>git rm –cached a.a 移除文件(只从暂存区中删除)</p>
<p>git commit -m “remove” 移除文件(从Git中删除)</p>
<p>git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)</p>
<p>git diff –cached 或 $ git diff –staged 查看尚未提交的更新</p>
<p>git stash push 将文件给push到一个临时空间中</p>
<p>git stash pop 将文件从临时空间pop下来</p>
<p>git remote add origin git@github.com:username/Hello-World.git</p>
<p>git push origin master 将本地项目给提交到服务器中</p>
<p>git pull 本地与服务器端同步<br>git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。<br>git push origin serverfix:awesomebranch</p>
<p>git fetch 相当于是从远程获取最新版本到本地，不会自动merge</p>
<p>git commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：</p>
<p>git branch branch_0.1 master 从主分支master创建branch_0.1分支</p>
<p>git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0</p>
<p>git checkout branch_1.0/master 切换到branch_1.0/master分支<br>du -hs</p>
<p>mkdir WebApp</p>
<p>cd WebApp</p>
<p>git init</p>
<p>touch README</p>
<p>git add README</p>
<p>git commit -m ‘first commit’</p>
<p>git remote add origin git@github.com:daixu/WebApp.git</p>
<p>git push -u origin master</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/13/iOS百宝箱/" itemprop="url">
                  百宝箱(转)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-13T19:32:17+08:00" content="2015-06-13">
              2015-06-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="iOS百宝箱"><a href="#iOS百宝箱" class="headerlink" title="iOS百宝箱"></a>iOS百宝箱</h1><h3 id="入门视频推荐"><a href="#入门视频推荐" class="headerlink" title="入门视频推荐"></a>入门视频推荐</h3><p>   <a href="http://pan.baidu.com/s/1cHnl2u">算法与数据结构</a>密码: bhhi          </p>
<p>   <a href="http://open.163.com/special/opencourse/ios8.html">斯坦福大学公开课iOS8全12集</a>  </p>
<p>   <a href="https://itunes.apple.com/cn/course/developing-ios-9-apps-swift/id1104579961">斯坦福大学公开课iOS9Swift版</a> 没字幕，白胡子老爷爷的视频，适合英语水平不错的童鞋<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/06/13/iOS百宝箱/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/11/CocoaPods的使用/" itemprop="url">
                  CocoaPods的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-11T22:51:17+08:00" content="2015-06-11">
              2015-06-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CocoaPods的使用"><a href="#CocoaPods的使用" class="headerlink" title="CocoaPods的使用"></a>CocoaPods的使用</h1><ul>
<li>Podfile.lock文件<ul>
<li>最后一次更新Pods时, 所有第三方框架的版本号</li>
</ul>
</li>
<li>常用指令的区别<ul>
<li>pod install<ul>
<li>会根据Podfile.lock文件中列举的版本号来安装第三方框架</li>
<li>如果一开始Podfile.lock文件不存在, 就会按照Podfile文件列举的版本号来安装第三方框架</li>
<li>安装框架之前, 默认会执行pod repo update指令</li>
</ul>
</li>
<li>pod update<ul>
<li>将所有第三方框架更新到最新版本, 并且创建一个新的Podfile.lock文件</li>
<li>安装框架之前, 默认会执行pod repo update指令</li>
</ul>
</li>
<li>pod install –no-repo-update</li>
<li>pod update –no-repo-update<ul>
<li>安装框架之前, 不会执行pod repo update指令”</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/04/SDWebImage的内部实现/" itemprop="url">
                  SDWebImage的内部实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-04T20:51:17+08:00" content="2015-05-04">
              2015-05-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#SDWebImage简介<br>SDWebImage是一个非常常用的开源第三方库,最简单的使用方式是以UIImageView类目的方式提供下载网络图片的方法.除此之外,还可以使用它作为图片异步下载器,图片自动缓存,支持gif动态图等,他会保证相同的URL图片资源只下载一次,永远不会锁住主线程,同时支持GCD和ARC,ARM64.使用SDWebImage下载网络图片可以提高性能.</p>
<p>#在项目中的实际使用</p>
<p>#1.第一步，下载SDWebImage，导入工程。github托管地址<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a></p>
<p>#2.第二步,在需要的地方导入头文件 #import “UIImageView+WebCache.h”</p>
<p>#3.第三步,调用sd_setImageWithURL : 方法缓存图片, 2.0版本是使用setImageWithURL:<br>1&gt;图片缓存的基本代码<br>sd_setImageWithURL:<br>[self.image sd_setImageWithURL: imageUrl];<br>2&gt; sd_setImageWithURL:completed:<br>[self.image sd_setImageWithURL: imageUrl completed:^(UIImage <em>iamge,NSError </em>err,SDImageCacheType cacheType, NSURL <em>imageURL){<br>NSLog(@”这里可以在图片加载之后做一些事情”)<br>}];<br>3&gt;设置一张占位图片,当图片加载完成之后在替换<br>sd_setImageWithURL:placeholderImage:<br>[self.image sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@”default”]];<br>4&gt;使用默认图片,而且用block在完成之后做一些事情<br>sd_setImageWithURL:  placeholderImage:  completed:<br>[self.image sd_setImageWithURL:imagePath placeholderImage:[UIImage imageNamed:@”default”] completed:^(UIImage </em>image, NSError <em>error, SDImageCacheType cacheType, NSURL </em>imageURL) {<br>        NSLog(@”图片加载完成后做的事情”);<br>    }];<br>5&gt;sd_setImageWithURL:  placeholderImage: options<br>失败后重试<br>[self.image sd_setImageWithURL:imagePath placeholderImage:[UIImage imageNamed:@”default”] options:SDWebImageRetryFailed];</p>
<p>#可选项options的所有选项</p>
<pre><code>// 失败后重试
SDWebImageRetryFailed = 1 &lt;&lt; 0,

//UI交互期间开始下载，导致延迟下载比如UIScrollView减速。
SDWebImageLowPriority = 1 &lt;&lt; 1,

//只进行内存缓存
SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,

//这个标志可以渐进式下载,显示的图像是逐步在下载
SDWebImageProgressiveDownload = 1 &lt;&lt; 3,

//刷新缓存
SDWebImageRefreshCached = 1 &lt;&lt; 4,

//后台下载
SDWebImageContinueInBackground = 1 &lt;&lt; 5,

//NSMutableURLRequest.HTTPShouldHandleCookies = YES;

SDWebImageHandleCookies = 1 &lt;&lt; 6,

//允许使用无效的SSL证书
//SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,

//优先下载
SDWebImageHighPriority = 1 &lt;&lt; 8,

//延迟占位符
SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,

//改变动画形象
SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,
</code></pre><p>#二 SDWebImage的内部实现过程<br>1.入口 setImageWithURL:placeholderImage:options:<br>先把  placeholderImage 显示<br>然后   SDWebImageManager 根据 URL 开始处理图片。<br>2.进入SDWebImageManager- downLoadImageWithURL :delegate:options:userInfo:<br>交给SDImageCache从缓存中查找图片是否已经下载完毕(通过方法queryDiskCacheForKey:delegate:userInfo:)<br>3.首先从内存图片缓存中查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。<br>4.SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。<br>5.内存缓存中没有,生成NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存.<br>6.根据UELKey在硬盘缓存目录下尝试读取图片文件,这一步实在NSOperation进行的操作,所以会主线程进行结果回调notifyDelegate;<br>7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。<br>8.如果从硬盘缓存目录读取不到图片,说明所有缓存中都不存在该图片,需要下载图片,回调imageCache:didNotFindImageForKey: userInfo;<br>9.共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。<br>10.图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。<br>11.connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。<br>12.connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。<br>13.图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。<br>14.在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。<br>15.imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。<br>16.通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。<br>17.将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。<br>18.SDImageCache在初始化的时候会注册一些消息通知,在内存警告或者推到后台的时候清理内存图片缓存,应用结束的时候清理过期图片.<br>19.SDWebImage 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。<br>20.SDWebImagePrefetcher 可以预先下载图片，方便后续使用。<br>SDWebImage库的作用：<br>通过对UIImageView的类别扩展来实现异步加载替换图片的工作。</p>
<p>#主要用到的类和对象：<br>1、UIImageView (WebCache)类别，入口封装，实现读取图片完成后的回调<br>2、SDWebImageManager，对图片进行管理的中转站，记录那些图片正在读取。<br>向下层读取Cache（调用SDImageCache），或者向网络读取对象（调用SDWebImageDownloader） 。<br>实现SDImageCache和SDWebImageDownloader的回调。<br>3、SDImageCache，根据URL的MD5摘要对图片进行存储和读取（实现存在内存中或者存在硬盘上两种实现）<br>实现图片和内存清理工作。<br>4、SDWebImageDownloader，根据URL向网络读取数据（实现部分读取和全部读取后再通知回调两种方式）</p>
<p>其他类：<br>SDWebImageDecoder，异步对图像进行了一次解压</p>
<p>#特别注意</p>
<p>#1、SDImageCache是怎么做数据管理的?<br>SDImageCache分两个部分，一个是内存层面的，一个是硬盘层面的。<br>内存层面的相当是个缓存器，以Key-Value的形式存储图片。当内存不够的时候会清除所有缓存图片。<br>用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。<br>当SDWebImageManager向SDImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，然后做Decoder，将图片对象放到内存层面做备份，再返回调用层。</p>
<p>#2、为什么必须做Decoder?<br>通过这个博客：<a href="http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/" target="_blank" rel="external">http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/</a><br>了解到，由于UIImage的imageWithData函数是每次画图的时候才将Data解压成ARGB的图像<br>所以在每次画图的时候，会有一个解压操作，这样效率很低，但是只有瞬时的内存需求。<br>为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了。<br>这种做法是典型的空间换时间的做法.</p>
<p>#最后整理一波思路<br>1.入口 setImageWithURL:placeholderImage:options: 显示占位图<br>                      |<br>        2.SDWebImageManager根据url处理图片<br>                      |</p>
<ol>
<li>SDWebImageManager调用downloadWithURL方法-&gt;让SDImageCache从缓存查找图片是否已经下载                              <pre><code>         |
先从内存缓存中查找                             
       有|
</code></pre></li>
<li>SDImageCacheDelegate回调 didFindImage到SDWebImageManager<br>SDWebImageManagerDelegate回调didFinishWithImage到<br>UIImageView+WebCache 等前端展示图片<pre><code>没有|
</code></pre>5.生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存<pre><code>|
</code></pre></li>
<li>根据URLKey在硬盘缓存目录下尝试读取图片文件.NSOperation中完成<pre><code>读取到|
</code></pre>7.将图片添加到内存缓存中,内存缓存过小,会先清空内存缓存SDImageCacheDelegate回调didFindImage到SDWebImageManager <pre><code>没有读取到|
</code></pre>8.SDImageCacheDelegate回调imagedidNotFindImageForKey<pre><code>|
</code></pre>9.共享或重新生成一个下载器SDWebImageDownloader开始下载图片<pre><code>|
</code></pre>10.图片下载由 NSURLConnection负责 通过监听代理方法可以判断图片下载中和下载完成和下载失败.<pre><code>|
</code></pre>11.可以在connection:didReceiveData:中实现按图片下载进度加载效果<pre><code>|
</code></pre>12.connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。<pre><code>|
</code></pre>13.图片解码处理在一个NSOperationQueue中完成,不会拖慢主线程UI. #mark:如果有需要对下载图片进行二次处理可以在这里<pre><code>|
</code></pre>14.在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。<pre><code>|
</code></pre>15.imageDownIoader:didFinishWithImage:回调给SDWebImageManager告知图片下载完成<pre><code>|
</code></pre>16.通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。<pre><code>|
</code></pre>17.将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以 NSInvocationOperation 完成，避免拖慢主线程<pre><code>|
</code></pre>18.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片<pre><code>|
</code></pre>19.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/02/Scoket以及TCP:IP的理解/" itemprop="url">
                  Scoket以及TCP/IP的理解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-02T09:51:17+08:00" content="2015-05-02">
              2015-05-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#socket简介及特性<br>1.socket（套接字）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
<p>2.多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，计算机操作系统为应用程序与TCP/IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<p>3.建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<p>Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接,UDP连接同理。</p>
<p>#CocoaAsyncSocket<br>iOS的socket实现是特别简单的，可以使用用github的开源类库cocoaasyncsocket简化开发，cocoaasyncsocket是支持tcp和ump的。代码大概如下：</p>
<ul>
<li>(IBAction)connectToServer:(id)sender {<br>  // 1.与服务器通过三次握手建立连接<br>  NSString <em>host = @”133.33.33.1”;<br>  int port = 1212;<br>  //创建一个socket对象<br>  _socket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)];<br>  //连接<br>  NSError </em>error = nil;<br>  [_socket connectToHost:host onPort:port error:&amp;error];<pre><code>if (error) {
    NSLog(@&quot;%@&quot;,error);
}
</code></pre>  }<br>  #pragma mark -socket的代理<br>  #pragma mark 连接成功<br>  -(void)socket:(GCDAsyncSocket <em>)sock didConnectToHost:(NSString </em>)host port:(uint16_t)port{<pre><code>NSLog(@&quot;%s&quot;,__func__);
</code></pre>  }<br>  #pragma mark 断开连接<br>  -(void)socketDidDisconnect:(GCDAsyncSocket <em>)sock withError:(NSError </em>)err{<br>  if (err) {<pre><code>NSLog(@&quot;连接失败&quot;);
</code></pre>  }else{<pre><code>NSLog(@&quot;正常断开&quot;);
</code></pre>  }<br>}<br>#pragma mark 数据发送成功<br>-(void)socket:(GCDAsyncSocket <em>)sock didWriteDataWithTag:(long)tag{<br>NSLog(@”%s”,<strong>func</strong>);<br>//发送完数据手动读取，-1不设置超时<br>[sock readDataWithTimeout:-1 tag:tag];<br>}<br>#pragma mark 读取数据<br>-(void)socket:(GCDAsyncSocket </em>)sock didReadData:(NSData <em>)data withTag:(long)tag{<br>NSString </em>receiverStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];<br>NSLog(@”%s %@”,<strong>func</strong>,receiverStr);<br>}</li>
</ul>
<p>#网络七层协议</p>
<p>网络七层协议由下往上分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。其中物理层、数据链路层和网络层通常被称作媒体层，是网络工程师所研究的对象；传输层、会话层、表示层和应用层则被称作主机层，是用户所面向和关心的内容。</p>
<p>#HTTP协议对应于应用层，TCP协议对应于传输层，IP协议对应于网络层，HTTP协议是基于TCP连接的,三者本质上没有可比性。 TCP/IP是传输层协议，主要解决数据如何在网络中传输；</p>
<p>#HTTP是应用层协议，主要解决如何包装数据。Socket是应用层与TCP/IP协议簇通信的中间软件抽象层，是它的一组接口。</p>
<ul>
<li>TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。</li>
</ul>
<p>//面向连接 类似于打电话 —–面向非连接 类似于邮件</p>
<ul>
<li>UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。</li>
</ul>
<p>TCP是一种流模式的协议，UDP是一种数据报模式的协议。</p>
<p>在传输数据时，可以只使用传输层（TCP/IP），但是那样的话，由于没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用应用层协议（HTTP、FTP、TELNET等），也可以自己定义应用层协议。</p>
<p>WEB使用HTTP作传输层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发送到网络上。</p>
<p>#Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p>
<p>#TCP连接</p>
<p>要想明白Socket连接，先要明白TCP连接。手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。</p>
<p>建立起一个TCP连接需要经过“三次握手”：</p>
<ol>
<li><p>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
</li>
<li><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
</li>
<li><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
</li>
</ol>
<p>#三次握手(Three-way Handshake)即建立一个TCP连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换TCP 窗口大小信息。在socket编程中，客户端执行connect()时,将触发三次握手。</p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”。</p>
<p>TCP连接的拆除需要发送四个包，因此称为四次握手(four-way handshake)。在socket编程中，任何一方执行close()操作即可产生握手（有地方称为“挥手”）操作。</p>
<p>之所以有“三次握手”和“四次握手”的区别，是因为连接时当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<p>#HTTP连接</p>
<p>HTTP协议即超文本传送协议(HypertextTransfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</p>
<p>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p>
<p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，是HTTP的安全版。 在HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息。</p>
<p>https协议需要到ca申请证书；http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议；http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443；http的连接很简单，是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。</p>
<p>#Socket连接与HTTP连接的不同</p>
<p>通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际应用中，客户端到服务器之间的通信防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p>
<p>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/08/UITableView的优化技巧/" itemprop="url">
                  UItableView优化常用方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-08T10:51:17+08:00" content="2015-04-08">
              2015-04-08
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#UItableViewCell的重用机制</p>
<p>#1.UItableView最核心的思想就是UItableViewCell的重用机制<br>-&gt; 简单的理解就是UItableView只会创建一个屏幕的UItableViewCell,其他的都是从缓存池中根据重用标识符抽取出来的.<br>-&gt;每当Cell画出屏幕时,就会被放到一个集合也就是缓存池(重用池)中当要显示某一位置的Cell时,会先去从缓存池中去,如果有,有直接拿来显示,如果没有,才会创建,这样做可以极大地减少了内存的开销.</p>
<p>#2.UITableView的回调方法<br>-&gt;UItableView最主要的两个回调方法是tableView:cellForRowAtIndexPath:<br>-&gt;tableView:heightForRowAtIndexPath:</p>
<p>#那么这两个方法调用的顺序是什么呢?<br>UItableView是继承自UIScrollView,所以需要先确定他的contentSize以及每个Cell的位置,然后才会把冲用的Cell放置到对应的位置.所以UItableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:  用来确定contentSize以及每个Cell的位置,然后才会调用tableView:cellForRowAtIndexPath: 从而来显示在当前屏幕的Cell.</p>
<p>#3.那么优化具体是优化什么?<br>eg:如果现在要显示100个Cell，当前屏幕显示5个。<br>那么刷新（reload）UITableView时，<br>-&gt;UITableView会先调用100次tableView:heightForRowAtIndexPath:方法，<br>-&gt;然后调用5次tableView:cellForRowAtIndexPath:方法；<br>-&gt;滚动屏幕时，每当Cell滚入屏幕，都会调用<br>一次tableView:heightForRowAtIndexPath:<br>一次tableView:cellForRowAtIndexPath:方法。</p>
<p>#所以UItabelView得优化主要就是优化上面两个回调方法</p>
<p>#4.实际应用中优化的方法.</p>
<p>#项目未优化前:</p>
<ul>
<li>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath {<br>  ContacterTableCell </em>cell = [tableView   dequeueReusableCellWithIdentifier:@”ContacterTableCell”];<br>  if (!cell) {<pre><code>cell = (ContacterTableCell *)[[[NSBundle mainBundle] loadNibNamed:@&quot;ContacterTableCell&quot; owner:self options:nil] lastObject];
</code></pre>  }<br>  NSDictionary *dict = self.dataList[indexPath.row];<br>  [cell setContentInfo:dict];<br>  return cell;<br>}</li>
<li>(CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath {<br>  UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];<br>  return cell.frame.size.height;<br>}<br>#我们分析一下上面代码在实际应用时,由于在heightForRowAtIndexPath:方法中调用了cellForRowAtIndexPath:indexPath:这个方法<br>当Cell赋值内容,会根据内容设置布局，当然也就可以知道Cell的高度,如果是电商类的项目,1K行Cell就算调用1K次cellForRowAtIndexPath: 这种方案自然是Pass的.</li>
</ul>
<p>#改进方法1.</p>
<ul>
<li>(CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath {<br>  NSDictionary *dict = self.dataList[indexPath.row];<br>  return [ContacterTableCell cellHeightOfInfo:dict];<br>}<br>#思路: 赋值和计算布局分离  各司其职,互不干扰. 不互相调用.</li>
</ul>
<p>#改进1+:直接先根据数据源计算出对应的布局，并缓存到数据源中</p>
<ul>
<li>(CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath {<br>  NSDictionary *dict = self.dataList[indexPath.row];<br>  return [ContacterTableCell cellHeightOfInfo:dict];<br>}<br>这样在heightForRowAtIndexPath:方法中就直接返回高度不需要每次计算</li>
</ul>
<p>#改进方法2:自定义Cell的绘制.<br>我们在Cell上添加系统控件的时候,实质上系统都需要调用底层接口进行绘制,当我们添加大量控件时,对资源的开销也会很大,所以我们可以索性,提高效率.</p>
<p>#代码如下:<br>首先需要给自定义的Cell添加draw方法,(或者重写drawRect)</p>
<p>1.//异步绘制<br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>        CGRect rect = [_data[@”frame”] CGRectValue];<br>        UIGraphicsBeginImageContextWithOptions(rect.size, YES, 0);<br>        CGContextRef context = UIGraphicsGetCurrentContext();</p>
<p>2.//整个内容的背景<br>        [[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1] set];<br>        CGContextFillRect(context, rect);</p>
<p>3.//转发内容的背景<br>        if ([_data valueForKey:@”subData”]) {<br>            [[UIColor colorWithRed:243/255.0 green:243/255.0 blue:243/255.0 alpha:1] set];<br>            CGRect subFrame = [_data[@”subData”][@”frame”] CGRectValue];<br>            CGContextFillRect(context, subFrame);<br>            [[UIColor colorWithRed:200/255.0 green:200/255.0 blue:200/255.0 alpha:1] set];<br>            CGContextFillRect(context, CGRectMake(0, subFrame.origin.y, rect.size.width, .5));<br>        }<br>          {</p>
<p>4.//名字<br>            float leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;<br>            float x = leftX;<br>            float y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+6))/2-2+SIZE_GAP_TOP+SIZE_GAP_SMALL-5;<br>            [_data[@”name”] drawInContext:context withPosition:CGPointMake(x, y) andFont:FontWithSize(SIZE_FONT_NAME)<br>                             andTextColor:[UIColor colorWithRed:106/255.0 green:140/255.0 blue:181/255.0 alpha:1]<br>                                andHeight:rect.size.height];</p>
<ol>
<li>//时间+设备<pre><code>y += SIZE_FONT_NAME+5;
float fromX = leftX;
float size = [UIScreen screenWidth]-leftX;
NSString *from = [NSString stringWithFormat:@&quot;%@  %@&quot;, _data[@&quot;time&quot;], _data[@&quot;from&quot;]];
[from drawInContext:context withPosition:CGPointMake(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE)
       andTextColor:[UIColor colorWithRed:178/255.0 green:178/255.0 blue:178/255.0 alpha:1]
          andHeight:rect.size.height andWidth:size];
</code></pre>  }</li>
</ol>
<p>6.//将绘制的内容以图片的形式返回，并调主线程显示<br>UIImage *temp = UIGraphicsGetImageFromCurrentImageContext();<br>        UIGraphicsEndImageContext();<br>        dispatch_async(dispatch_get_main_queue(), ^{<br>            if (flag==drawColorFlag) {<br>                postBGView.frame = rect;<br>                postBGView.image = nil;<br>                postBGView.image = temp;<br>            }<br>}<br>//内容如果是图文混排，就添加View，用CoreText绘制<br>[self drawText];<br>}}</p>
<p>#如果重写drawRect就不需要用GCD异步线程,drawRect本身就是异步绘制.</p>
<p>#3.滑动UItableView时,按需加载对应的内容.<br>代码如下:<br>//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。</p>
<ul>
<li>(void)scrollViewWillEndDragging:(UIScrollView <em>)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint </em>)targetContentOffset{<br>  NSIndexPath <em>ip = [self indexPathForRowAtPoint:CGPointMake(0, targetContentOffset-&gt;y)];<br>  NSIndexPath </em>cip = [[self indexPathsForVisibleRows] firstObject];<br>  NSInteger skipCount = 8;<br>  if (labs(cip.row-ip.row)&gt;skipCount) {<pre><code>NSArray *temp = [self indexPathsForRowsInRect:CGRectMake(0, targetContentOffset-&gt;y, self.width, self.height)];
NSMutableArray *arr = [NSMutableArray arrayWithArray:temp];
if (velocity.y&lt;0) {
    NSIndexPath *indexPath = [temp lastObject];
    if (indexPath.row+33) {
        [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-3 inSection:0]];
        [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-2 inSection:0]];
        [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-1 inSection:0]];
    }
}
[needLoadArr addObjectsFromArray:arr];
</code></pre>  }<br>}<br>#在tableView:cellForRowAtIndexPath:方法中加入判断：</li>
</ul>
<p>if (needLoadArr.count&gt;0&amp;&amp;[needLoadArr indexOfObject:indexPath]==NSNotFound) {<br>    [cell clear];<br>    return;<br>}</p>
<p>#滚动很快时，只加载目标范围内的Cell，这样按需加载，极大的提高流畅度。</p>
<p>##总结:UITableView的优化主要从三个方面入手:</p>
<p>#1:提前计算并缓存好高度(布局),因为heightForRowAtIndexPath:是调用最频繁的方法;</p>
<p>#2:异步绘制,遇到复杂界面,遇到性能瓶颈时,可以从这一方面入手.</p>
<p>#3.滑动时按需加载-&gt;对于需要大量图片展示,网络加载的时候很管用!(SDWebImage已经实现异步加载，配合这条性能杠杠的).<br>除了上面这几点,还有一些常用被大家熟知的优化点:</p>
<p>#4.正确使用reuseIdentifier来重用</p>
<p>#5.尽量使所有的View 不透明,包括Cell自身,少用或者不用透明图层</p>
<p>#6.如果Cell内的内容来自Web,使用异步加载,缓存请求结果</p>
<p>#7.减少subViews的数量</p>
<p>#8.尽量少用addView给Cell添加View,可以在初始化的时候添加,通过hide属性控制是否显示</p>
<p>#结尾 为什么都是手动用代码创建Cell的？现在主流不都是Xib、Storyboard什么的嘛？<br>原因是：要想提高效率，还是手动写有用！抛开Xib、Storyboard需要系统自动转码，给系统多加了一层负担不谈，自定义Cell的绘制更是无从下手，所以，复杂的需要高效的界面，还是手动写代码吧！！！</p>
<p>最后如果项目都是用的Xib、Storyboard，并需要优化UITableView的话，sunnyxx大神提出了好的方案：<br><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/</a> 大伙可以自行研究研究。</p>
<p>注明：本篇的分析源码来源于开源项目VVeboTableViewDemo</p>
<p>参考：<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="external">https://github.com/johnil/VVeboTableViewDemo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/11/UITableView的重用机制详解/" itemprop="url">
                  UITableView的重用机制详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-11T13:31:17+08:00" content="2015-03-11">
              2015-03-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#写这篇文章的原因是为了加深对UITableView的重用机制的理解</p>
<p>#首先,我们要明白我们为什么需要使用这种机制,其次,这种机制的原理是什么.<br>举例说明:</p>
<p>一个UITableView中有许多需要显示的cell,但是我们不可能每个都会浏览到,那么如果我们把这些数据全部都加载进去,是不是造成了内存的负担呢.</p>
<p>我们所能显示的区域通常只有一个屏幕的大小,那么那些屏幕之外的信息是不需要一次性全都加载完的,只有当我们滑动屏幕需要浏览的时候,我们才需要它加载进来.因此,就有了要介绍的这部分内容,UITabelViewCell的重用机制.</p>
<p>重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell,我们只创建屏幕可显示的最大的cell个数+1,然后去循环重复使用这些cell,既节省空间,又达到我们需要显示的效果.</p>
<p>#1.通过利用运行时 输出UITableView所有的成员变量,会找到NSMutableArray<em> visibleCells 和NSMutableDictionary</em> resuableTableCells两个属性.<br>visibleCells保存当前显示的Cells.<br>reusableTableCells保存可重用的Cells.</p>
<p>TableView显示之初,resuableTableCells为空,<br>所以tableView dequeueReusableCellWithIdentifier:CellIdentifier返回nil。<br>开始的cell 都是通过<br>[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellI dentifier] 来创建,<br>且cellForRowAtIndexPath只是调用最大显示cell数的次数。</p>
<p>#eg:有100条数据,iPhone一个屏幕最多显示5个Cell.程序最开始显示TableView的情况是:</p>
<ol>
<li><p>用[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]创建10次cell，并给cell指定同样的重用标识(可以为不同显示类型的cell指定不同的标识)。并且10个cell全部都加入到visiableCells数组，reusableTableCells为空。</p>
</li>
<li><p>向下拖动tableView，当cell1完全移出屏幕，并且cell6(它也是alloc出来的，原因同上)完全显示出来的时候。cell6加入到visiableCells，cell1移出visiableCells，cell6加入到reusableTableCells。</p>
</li>
<li><p>接着向下拖动tableView，因为reusableTableCells中已经有值，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用的时候，tableView dequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。cell1加入到visiableCells，cell1移出reusableTableCells；cell2移出visiableCells，cell2加入到reusableTableCells。之后再需要显示的Cell就可以正常重用了。</p>
</li>
</ol>
<p>所以整个过程并不难理解，但需要注意正是因为这样的原因：配置Cell的时候一定要注意，对取出的重用的cell做重新赋值，不要遗留老数据。</p>
<p>#一些情况：</p>
<p>　　使用过程中，并不是只有拖动超出屏幕的时候才会更新reusableTableCells表，还有：</p>
<p>　　1. reloadData，这种情况比较特殊。一般是部分数据发生变化，需要重新刷新cell显示的内容时调用。在cellForRowAtIndexPath调用中，所有cell都是重用的。reloadData调用后，把visiableCells中所有cell移入reusableTableCells，visiableCells清空。cellForRowAtIndexPath调用后，再把reuse的cell从reusableTableCells取出来，放入到visiableCells。</p>
<p>　　2. reloadRowsAtIndex，刷新指定的IndexPath。如果调用时reusableTableCells为空，那么cellForRowAtIndexPath调用后，是新创建cell，新的cell加入到visiableCells。老的cell移出visiableCells，加入到reusableTableCells。于是，之后的刷新就有cell做reuse了。</p>
<p>#注意：</p>
<p>1-重取出来的cell是有可能已经捆绑过数据或者加过子视图的，所以，如果有必要，要清除数据（比如textlabel的text）和remove掉add过的<br>子视图（使用tag）。<br>2-这样设计的目的是为了避免频繁的 alloc和delloc cell对象而已,没有多复杂。<br>3-设计的关键是实现cell和数据的完全分离<br>重点：避免重用机制出错</p>
<p>1.重用机制调用的就是dequeueReusableCellWithIdentifier这个方法，方法的意思就是“出列可重用的cell”，因而只要将它换为cellForRowAtIndexPath（只从要更新的cell的那一行取出cell），就可以不使用重用机制，因而问题就可以得到解决，但会浪费一些空间</p>
<p>2.为每个cell指定不同的重用标识符(reuseIdentifier)来解决。重用机制是根据相同的标识符来重用cell的，标识符不同的cell不能彼此重用。</p>
<p>[cpp] view plain copy print?<br>NSString *identifier = [NSString stringWithFormat:@”TimeLineCell%d%d”,indexPath.section,indexPath.row];  </p>
<p>3.删除重用的cell的所有子视图，从而得到一个没有特殊格式的cell，供其他cell重用。</p>
<p>[cpp] view plain copy print?<br>if (cell == nil) {<br>        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier];<br>    }<br>    else<br>    {<br>        //删除cell的所有子视图<br>        while ([cell.contentView.subviews lastObject] != nil)<br>        {<br>            [(UIView*)[cell.contentView.subviews lastObject] removeFromSuperview];<br>        }<br>    }   </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/author.jpg"
               alt="Xu Chu" />
          <p class="site-author-name" itemprop="name">Xu Chu</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xu Chu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
