<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="君子性非异也 善假于物也">
<meta property="og:url" content="http://.com/index.html">
<meta property="og:site_name" content="君子性非异也 善假于物也">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="君子性非异也 善假于物也">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 君子性非异也 善假于物也 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">君子性非异也 善假于物也</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'WEps6UsQK5do8sDRpD_N','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/30/Mutipeer Connectivity/" itemprop="url">
                  蓝牙交互-Mutipeer Connectivity
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-30T20:13:08+08:00" content="2016-06-30">
              2016-06-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Mutipeer Connectivity简介<br>iOS 7引入的一个全新框架 多点连接<br>替代GameKit框架 多用于文件的传输 </p>
<p>#iOS设备不联网也能跟附近的人聊天<br>FireChat<br>See You Around<br>以上聊天App都是基于mutipeerConnectivity框架</p>
<p>#搜索和传输的方式<br>双方WIFI和蓝牙都没有打开:无法实现<br>双方都开启蓝牙:通过蓝牙发现和传输<br>双方都开启WIFI:通过WIFI Direct发现和传输,速度接近AirDrop 双方同时开启了WIFI和蓝牙:模拟AirDrop,通过低功耗蓝牙技术扫描发现握手, 然后通过WIFI Direct传输</p>
<p>#实际使用<br>连接设备</p>
<p>#1.创建MCSession对象用于存放当前连接的会话<br>创建MCSession对象<br>initWithPeer:设备的ID<br>用于存放当前的连接的会话<br>self.mc_Session = [ [MCSession alloc]initWithPeer:[[MCPeerID alloc] initWithD<br>  开启广播对象,通知正在搜索的设备他们是可用的</p>
<p>只要开启了可被搜索的广播,那么连接蓝牙按钮就不可点 </p>
<ul>
<li>(IBAction)foundConnect:(id)sender {<br>  UISwitch <em>switchBtn = (UISwitch </em>)sender;<br>  if (switchBtn.isOn) {// 广播对象,告诉其它的设备他们是可用的<br>if (self.advertiserAssistant == nil) {<br>// 创建广播对象<br>// initWithServiceType: 广播类型的标示(因为广播可能比较多,所以最好每 // session:当前会话<br>// discoveryInfo: 广播信息<br>self.advertiserAssistant = [[MCAdvertiserAssistant alloc] initWit<br>}<br>// 开启广播 [self.advertiserAssistant start]; self.connectBT.enabled = NO;<br>  }else{<pre><code>self.connectBT.enabled = YES;
</code></pre>} }<br>#2.开始搜索蓝牙设备</li>
<li>(IBAction)connectBlueTooth {<br>// 创建搜索蓝牙设备控制器<br>MCBrowserViewController *mbVC = [[MCBrowserViewController alloc]initWithS // 设置控制器代理<br>mbVC.delegate = self;<br>// 跳转到搜索控制器<br>[self presentViewController:mbVC animated:YES completion:nil];<br>}<br>选择数据</li>
<li>(IBAction)selectImage {</li>
</ul>
<ol>
<li>创建图片选择器<br>UIImagePickerController *imgPicker = [[UIImagePickerController alloc]init // 2. 判断图片选择器是否可用<br>if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControlle<br>// 选择器打开的类型<br>imgPicker.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAl // 设置代理<br>imgPicker.delegate = self;</li>
<li>打开图片选择器<br>[self presentViewController:imgPicker animated:YES completion:nil];<br>} }<br>图片选择器代理中获取数据<br>// 选择完毕调用</li>
</ol>
<ul>
<li>(void)imagePickerController:(UIImagePickerController *)picker didFinishPick {<br>//<br>NSLog(@”info == %@”,info);<br>// 设置显示图片<br>self.showImage.image = info[UIImagePickerControllerOriginalImage]; // 隐藏图片显示器<br>[picker dismissViewControllerAnimated:YES completion:nil];<br>}<br>#在搜索控制器的连接完成的代理方法中隐藏搜索控制器<br>连接完成<br>@param browserViewController 搜索控制器 </li>
<li><p>(void)browserViewControllerDidFinish:(MCBrowserViewController <em>)browserView<br>{<br>  [browserViewController dismissViewControllerAnimated:YES completion:nil];<br>  NSLog(@”%s %d”,<strong>func</strong>,<strong>LINE</strong>);<br>}<br>发送数据<br>实现搜索控制器的代理方法,获取连接上的设备ID<br>#pragma mark - MCBrowserViewControllerDelegate<br>/*</em></p>
<h1 id="连接成功"><a href="#连接成功" class="headerlink" title="连接成功"></a>连接成功</h1><p>@param browserViewController 搜索控制器<br>在搜索控制器的连接完成的代理方法中隐藏搜索控制器<br>@param peerID<br>@param info<br>@return<br>连接上的设备ID 连接的信息<br>YES : 只发送连接上的用户</p>
</li>
<li><p>(BOOL)browserViewController:(MCBrowserViewController *)browserViewControlle</p>
<pre><code>shouldPresentNearbyPeer:(MCPeerID *)peerID
      withDiscoveryInfo:(nullable NSDictionary&lt;NSString *, NSString *&gt;
</code></pre><p>{<br>  self.peerID = peerID;<br>  NSLog(@”info == %@<br>return YES; }<br>将图片发送给连接上的ID</p>
</li>
<li>(IBAction)sendImage { // 获取图片<br>peer = %@”,info, peerID);<br>UIImage <em>image = self.showImage.image;<br>// 将图片转换成NSData类型<br>NSData </em>data = UIImagePNGRepresentation(image);<br>发送数据<br>toPeers : 发给的设备ID的数组<br>withMode: 发送模式,是否是安全模式 */<br>  if (self.peerID != nil) {<pre><code>[self.mc_Session sendData:data toPeers:@[self.peerID] withMode:MCSess
</code></pre>} }</li>
</ul>
<p>#接收数据</p>
<p>实现MCSession的代理方法接受数据</p>
<ul>
<li>(void)session:(MCSession <em>)session didReceiveData:(NSData </em>)data fromPeer:(<br>{<br>  NSLog(@”%s %d”,<strong>func</strong>,<strong>LINE</strong>);<br>  NSLog(@”data = %@ , peer = %@”,data,peerID);<br>}</li>
</ul>
<p>#显示数据<br>在MCSeesion代理方法中设置获取过来的数据<br>   接收的数据</p>
<ul>
<li>(void)session:(MCSession <em>)session didReceiveData:(NSData </em>)data fromPeer:( {<br>//<br>NSLog(@”%s %d”,<strong>func</strong>,<strong>LINE</strong>);<br>NSLog(@”data = %@ , peer = %@”,data,peerID);<br>UIImage *image = [[UIImage alloc]initWithData:data];<br>if(image != nil){<br>// 设置数据 dispatch_async(dispatch_get_main_queue(), ^{<pre><code>self.showImage.image = image;
</code></pre>  });<br>} }</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/30/CoreBlueTooth/" itemprop="url">
                  蓝牙交互-CoreBlueTooth
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-30T11:23:14+08:00" content="2016-06-30">
              2016-06-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#CoreBlueTooth简介<br>可用于第三方蓝牙设备交互,设备必须支持蓝牙4.0 iPhone的设备必须是4S及以上<br>iPad设备必须是iPad mini及以上<br>iOS的系统必须是iOS 6及以上 蓝牙4.0以低功耗著称,所以一般被称为BLE(bluetooth low energy) 使用模拟器调试</p>
<p>#应用场景<br>     运动手环<br>     智能家居<br>     拉卡拉蓝牙刷卡器</p>
<p>#核心概念<br>CBCentralManager:中心设备(用来连接到外部设备的管家) CBPeripheralManager:外部设备(第三方的蓝牙4.0设备)</p>
<p>#实际使用<br>  建立中心管家</p>
<p>#1. 创建中心管家,并且设置代理<br>self.cmgr = [[CBCentralManager alloc]initWithDelegate:self queue:nil];<br>扫描外设(discover)</p>
<p>#2. 在代理方法中扫描外部设备 /<em>*<br>scanForPeripheralsWithServices :如果传入指定的数组,那么就只会扫描数组中对应ID </em> 如果传入nil,那么就是扫描所有可以发现的设备<br> 扫描完外部设备就会通知CBCentralManager的代理</p>
<ul>
<li>(void)centralManagerDidUpdateState:(CBCentralManager *)central<br>{<br> if ([central state] == CBCentralManagerStatePoweredOn) {<pre><code>[self.cmgr scanForPeripheralsWithServices:nil options:nil];
</code></pre>} }</li>
</ul>
<hr>
<p>发现外部设备,每发现一个就会调用这个方法<br>所以可以使用一个数组来存储每次扫描完成的数组 </p>
<ul>
<li>(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBP<br>{<br>// 有可能会导致重复添加扫描到的外设<br>// 所以需要先判断数组中是否包含这个外设 if(![self.peripherals containsObject:peripheral]){<pre><code>[self.peripherals addObject:peripheral];
</code></pre>  }<br>}<br>连接外设</li>
</ul>
<ul>
<li>模拟开始连接方法 */</li>
</ul>
<ul>
<li>(void)start<br>{<br>#3. 连接外设<br>for (CBPeripheral *ppl in self.peripherals) { // 扫描外设的服务<br>// 这个操作应该交给外设的代理方法来做<br>// 设置代理<br>ppl.delegate = self;<br>[self.cmgr connectPeripheral:ppl options:nil];<br>} }<br>扫描外设中的服务和特征<br>#服务和特征的关系<br>每个蓝牙4.0的设备都是通过服务和特征来展示自己的,一个设备必然包含一个或 多个服务,每个服务下面又包含若干个特征。</li>
</ul>
<p>#连接外设成功调用</p>
<ul>
<li>(void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPe<br>{<br>// 查找外设服务<br>  [peripheral discoverServices:nil];<br>}</li>
</ul>
<h1 id="发现服务就会调用代理方法"><a href="#发现服务就会调用代理方法" class="headerlink" title="发现服务就会调用代理方法 *"></a>发现服务就会调用代理方法 *</h1><p> @param peripheral 外设 */</p>
<ul>
<li>(void)peripheral:(CBPeripheral <em>)peripheral didDiscoverServices:(NSError </em>)<br>{<br>// 扫描到设备的所有服务<br>NSArray <em>services = peripheral.services; // 根据服务再次扫描每个服务对应的特征<br>for (CBService </em>ses in services) {<pre><code>[peripheral discoverCharacteristics:nil forService:ses];
</code></pre>  }<br>}</li>
</ul>
<h1 id="发现服务对应的特征"><a href="#发现服务对应的特征" class="headerlink" title="发现服务对应的特征"></a>发现服务对应的特征</h1><ul>
<li>(void)peripheral:(CBPeripheral <em>)peripheral didDiscoverCharacteristicsForSe<br>{<br>// 服务对应的特征<br>NSArray </em>ctcs = service.characteristics; // 遍历所有的特征<br>for (CBCharacteristic *character in ctcs) {<br>// 根据特征的唯一标示过滤<br>if ([character.UUID.UUIDString isEqualToString:@”XMG”]) {<br>NSLog(@”可以吃饭了”); }<br>} }<br>#断开连接</li>
<li>(void)stop<br>与外设做数据交互<br>在指定的特征下做相应的操作<br>  Chapter-20(I)蓝牙交互CoreBlueTooth 151<br>r<br>e<br>r<br>MISSAJJ IOSDevelopment GitBook<br>{<br>// 断开所有连接上的外设<br>for (CBPeripheral *per in self.peripherals) {<pre><code>[self.cmgr cancelPeripheralConnection:per];
</code></pre>  }<br>}</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/29/蓝牙初步分析/" itemprop="url">
                  蓝牙初步分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-29T06:23:14+08:00" content="2016-06-29">
              2016-06-29
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#蓝牙分为GameKit(iOS7以后过期了) / Mutipeer Connectivity 和 CoreBluetooth三种框架</p>
<p>#1.获取照片<br>// 1.判断相册是否可用<br>if (![UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeSavedPhotosAlbum]) {<br>    NSLog(@”相册不可用”);<br>    return;<br>}<br>// 2.创建控制器<br>UIImagePickerController *imagePickerController = [[UIImagePickerController alloc] init];<br>// 3.设置照片来源<br>imagePickerController.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;<br>// 4.设置代理<br>imagePickerController.delegate = self;<br>// 5.弹出控制器<br>[self presentViewController:imagePickerController animated:YES completion:nil];</p>
<p>在代理方法imagePickerController: didFinishPickingMediaWithInfo:中可以获取到用户选择的照片<br>self.imageView.image = info[UIImagePickerControllerOriginalImage];</p>
<p>#2.搜索设备–&gt;弹出蓝牙连接控制器<br>// 1.创建蓝牙连接控制器<br>GKPeerPickerController *peerPickerController = [[GKPeerPickerController alloc] init];</p>
<p>// 2.设置代理<br>peerPickerController.delegate = self;<br>// 3.显示控制器<br>[peerPickerController show];</p>
<p>#3.代理方法中连接设备，设置接收数据的句柄<br>/**</p>
<ul>
<li>当连接到设备时调用<br>*</li>
<li>@param picker  控制器</li>
<li>@param peerID  设备ID</li>
<li>@param session 会话  用于接收和发送数据<br>*/<ul>
<li>(void)peerPickerController:(GKPeerPickerController <em>)picker didConnectPeer:(NSString </em>)peerID toSession:(GKSession *)session<br>{<br>// 保存会话<br>self.session = session;<br>// 设置句柄<br>[session setDataReceiveHandler:session withContext:nil];<br>// 销毁控制器<br>[picker dismiss];<br>}</li>
</ul>
</li>
</ul>
<p>#4.在官方文档中获取接收到的数据<br>/**</p>
<ul>
<li>接收到数据时调用<br>*/<ul>
<li>(void) receiveData:(NSData <em>)data fromPeer:(NSString </em>)peer inSession: (GKSession <em>)session context:(void </em>)context<br>{<br>UIImage *image = [UIImage imageWithData:data];<br>self.imageView.image = image;<br>}</li>
</ul>
</li>
</ul>
<p>#5.发送数据<br>NSData *data = UIImageJPEGRepresentation(self.imageView.image, 0.5);<br>[self.session sendDataToAllPeers:data withDataMode:GKSendDataReliable error:nil];</p>
<p>==================================================================================</p>
<p>CoreBluetooth</p>
<p>CoreBluetooth中，蓝牙的最小单位是特征，以下代码说白了就是为了获取特定的特征<br>// 1.中央管理者 (queue设置为nil，默认就是主队列)<br>_centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil];<br>// 2.扫描周边设备  –&gt;发现设备 –&gt;连接设备<br>[self.centralManager scanForPeripheralsWithServices:nil options:nil];</p>
<p>// 3.设置扫描服务<br>//扫描所有服务<br>[peripheral discoverServices:nil];</p>
<p>// 4.在代理方法中获取扫描特征<br>/**</p>
<ul>
<li>当扫描到服务时调用<br>*/<ul>
<li>(void)peripheral:(CBPeripheral <em>)peripheral didDiscoverServices:(NSError </em>)error<br>{<br>// 遍历所有服务<br>for (CBService *service in peripheral.services) {<br>  // 找到需要的服务<br>  if ([service.UUID.UUIDString isEqualToString:@”123”]) {<pre><code>// 4.扫描特征
[peripheral discoverCharacteristics:nil forService:service];
</code></pre>  }<br>}<br>}</li>
</ul>
</li>
</ul>
<p>// 5.在代理方法中获取特征，读取数据<br>/**</p>
<ul>
<li><p>当扫描到特征时调用<br>*/</p>
<ul>
<li><p>(void)peripheral:(CBPeripheral <em>)peripheral didDiscoverCharacteristicsForService:(CBService </em>)service error:(NSError <em>)error<br>{<br>// 遍历所有特征<br>for (CBCharacteristic </em>characteristic in service.characteristics) {<br>  //  找到需要的特征<br>  if ([characteristic.UUID.UUIDString isEqualToString:@”456”]) {</p>
<pre><code>// 5.发送数据
// 读取数据
[peripheral readValueForCharacteristic:characteristic];

// 写入数据
[peripheral writeValue:[NSData data] forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];
</code></pre><p>  }<br>}<br>}</p>
</li>
</ul>
</li>
</ul>
<p>#6.读取到的数据在相应代理方法中拿到<br>/**</p>
<ul>
<li>当有数据更新时调用<br>*/<ul>
<li>(void)peripheral:(CBPeripheral <em>)peripheral didUpdateValueForCharacteristic:(CBCharacteristic </em>)characteristic error:(NSError <em>)error<br>{<br>NSData </em>data = characteristic.value;<br>}</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/05/流媒体视频播放/" itemprop="url">
                  流媒体视频播放
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-05T14:22:17+08:00" content="2016-06-05">
              2016-06-05
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="流媒体视频播放"><a href="#流媒体视频播放" class="headerlink" title="流媒体视频播放"></a>流媒体视频播放</h1><pre><code>1.伪流媒体
没有使用RTMP,HSL等流媒体协议,使用HTTP协议.可以实现视频播放,可以实现快进快退等,体验上和流媒体相似,优酷,土豆使用的是这项技术.
优点:实现简单,成本低

2.流媒体
HLS:苹果基于HTTP开发的流媒体协议
首先通过设备采集音视频信息,对原始数据进行H264编码和AAC编码后上传到服务器
服务器保存的HLS文件是有若干个.ts文件和M3u8文件
在播放的时候发送url需要m3u8文件 
m3u8:本质是一个地址,通过它可以找到服务器里对应保存的文件

3.RTMP:实时消息传输协议(相对于HSL 延迟低) 该协议基于TCP，是一个协议族
RTMP有个弱点就是累积误差，原因是RTMP基于TCP不会丢包。
所以当网络状态差时，服务器会将包缓存起来，导致累积的延迟；
待网络状况好了，就一起发给客户端。
这个的解决方法就是，当客户端的缓冲区很大，就断开重连。
</code></pre><h1 id="如何播放"><a href="#如何播放" class="headerlink" title="如何播放"></a>如何播放</h1><pre><code>1. HTTP协议, HLS, MPMoviePlayerController / MPMoviePlayerViewController/AVPlayer

 RTMP等其他协议时, 就需要使用第三方(ffmpeg/VLC)  

2.使用第三方ijkplayer --&gt; 封装的ffmpeg
 1. 支持更多的协议及格式
 2. 按照第三方集成会很方便

3. 使用第三SDK
百度/腾讯/网易/直播/流媒体框架
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/iOS图片圆角优化/" itemprop="url">
                  iOS图片圆角优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T16:32:17+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS图片圆角优化"><a href="#iOS图片圆角优化" class="headerlink" title="iOS图片圆角优化"></a>iOS图片圆角优化</h1><p>##为什么要进行圆角优化?<br>苹果自带的给图片设置圆角的方法:</p>
<p>ImageView.clipsToBounds = YES;<br>[ImageView.layer setCornerRadius:50];</p>
<p>但是这样设置会触发离屏渲染,比较消耗性能,比如一个页面上有十几个头像这样设置圆角会明显感觉到卡顿.</p>
<p>##设置圆角的方法</p>
<p>###1.直接使用setCornerRadius</p>
<p>####这种就是最常用的，也是最耗性能的。</p>
<p>setCornerRadius设置圆角之后，shouldRasterize=YES光栅化</p>
<p>avatarImageView.clipsToBounds = YES; [avatarImageView.layer setCornerRadius:50]; avatarImageView.layer.shouldRasterize = YES;</p>
<p>shouldRasterize=YES设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图， 使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。</p>
<p>但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新 创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。</p>
<p>问题：我发现UIImageView上加载网络图片使用光栅化会有一点模糊，而UIButton 上使用光栅化没有模糊，不知道为什么？求大神解答！</p>
<p>###2.直接覆盖一张中间为圆形透明的图片</p>
<p>这种方法就是多加了一张透明的图片，GPU计算多层的混合渲染blending也是会消耗 一点性能的，但比第一种方法还是好上很多的。</p>
<p>Core Graphics绘制圆角</p>
<p>####这种方式性能最好，但是UIButton上不知道怎么绘制，可以用UIimageView添加个 点击手势当做UIButton使用。</p>
<p>  UIGraphicsBeginImageContextWithOptions(avatarImageView.bounds.size, NO, [UIScreen mainScreen].scale);<br>  [[UIBezierPath bezierPathWithRoundedRect:avatarImageView.bounds cornerRadius:50] addClip];<br>  [image drawInRect:avatarImageView.bounds];<br>  avatarImageView.image = UIGraphicsGetImageFromCurrentImageContext();<br>  UIGraphicsEndImageContext();<br>这段方法可以写在SDWebImage的completed回调里，也可以在UIImageView+WebCache.h 里添加一个方法，isClipRound判断是否切圆角，把上面绘制圆角的方法封装到里面。</p>
<ul>
<li>(void)sd_setImageWithURL:(NSURL <em>)url placeholderImage:(UIImage </em>)placeholder options:(SDWebImageOptions)options isClipRound:(BOOL)isRound progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock;<br>使用Instruments的Core Animation查看性能</li>
</ul>
<p>Color Offscreen-Rendered Yellow</p>
<p>开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。</p>
<p>Color Hits Green and Misses Red</p>
<p>如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。</p>
<p>用Instruments测试得</p>
<p>####第一种方法，ios9.0之前UIImageView和UIButton都高亮为黄色。ios9.0之后只有UIButton高亮为黄色。</p>
<p>####第二种方法UIImageView和UIButton都高亮为绿色，但UIImageView加载网络图片后会有一点模糊</p>
<p>####第三种方法无任何高亮，说明没离屏渲染</p>
<p>####第四种方法无任何高亮，说明没离屏渲染</p>
<p>#一行代码设置图片圆角</p>
<p>##图片圆角渲染工具HJCornerRadius，其最大优势在于使用简单，一行搞定图片圆角</p>
<p>1.<br>imageview.aliCornerRadius = 5.0f;<br>核心思想就是使用圆角图片替换系统圆角。实际使用时，确保layer对象的masksToBounds属性为NO</p>
<p>2.<br>imageview.layer.masksToBounds = NO</p>
<p>3.<br>pod ‘HJCornerRadius’, :git =&gt; “<a href="https://github.com/panghaijiao/HJCornerRadius.git" target="_blank" rel="external">https://github.com/panghaijiao/HJCornerRadius.git</a>“</p>
<p>RunLoop的适当切换</p>
<p>##工具原理<br>这个工具并不是直接渲染原始Image对象，而是先截取UIImageView视图Layer生成的Image，然后再做渲染。原因很简单，因为UIImageView呈现方式涉及多种ContentMode，通过渲染UIImageView视图Layer生成的图片可以巧妙的解决UIImageView显示模式的问题</p>
<p>此外，由于系统原因，对于像UITableViewCell的UIImageView，第一次创建赋图时，可能无法获取UIImageView视图Layer的图片，此时，可以通过切换异步RunLoop达到延时渲染的目的</p>
<p>众所周知，截图渲染的逻辑是可以运行在工作线程，但是本工具并没有把它们放在工作线程执行，因为放在工作线程会有延迟，从而导致图片闪烁的现象</p>
<p>具体截图渲染代码如下</p>
<p>UIGraphicsBeginImageContextWithOptions(self.originImageView.bounds.size, NO, [UIScreen mainScreen].scale);</p>
<pre><code>CGContextRef currnetContext = UIGraphicsGetCurrentContext();
CGContextAddPath(currnetContext, [UIBezierPath bezierPathWithRoundedRect:self.originImageView.bounds cornerRadius:self.cornerRadius].CGPath);
CGContextClip(currnetContext);
[self.originImageView.layer renderInContext:currnetContext];
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

if ([image isKindOfClass:[UIImage class]]) {
    image.aliCornerRadius = YES;
    self.originImageView.image = image;
} else {
    dispatch_async(dispatch_get_main_queue(), ^{
        [self updateImageView];
    });
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/25/RunLoop原理和核心机制/" itemprop="url">
                  RunLoop原理及核心机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-25T22:23:14+08:00" content="2016-02-25">
              2016-02-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#RunLoop的定义</p>
<p>当有持续的异步任务需求时，我们需要创建一个独立的生命周期可控的线程。RunLoop就是控制线程生命周期并接收事件进行处理的机制。</p>
<p>#RunLoop是iOS事件响应与任务处理最核心的机制，它贯穿iOS整个系统。</p>
<p>Foundation: NSRunLoop<br>Core Foundation: CFRunLoop 核心部分，代码开源，C 语言编写，跨平台</p>
<p>#1.目的</p>
<p>通过RunLoop机制实现省电，流畅，响应速度快，用户体验好</p>
<p>#2.理解</p>
<p>进程相当于一家工厂，线程则是一个流水线，Run Loop属于流水线上的主管；<br>1&gt;当工厂接到商家的订单分配给这个流水线时，Run Loop就启动这个流水线，让流水线动起来，生产产品；<br>2&gt;当产品生产完毕时，Run Loop就会暂时停下流水线，节约资源。<br>RunLoop管理流水线，流水线才不会因为无所事事被工厂销毁；而不需要流水线时，就会辞退RunLoop这个主管，即退出线程，把所有资源释放。</p>
<p>#RunLoop并不是iOS平台的专属概念，在任何平台的多线程编程中，为控制线程的生命周期，接收处理异步消息都需要类似RunLoop的循环机制实现，Android的Looper就是类似的机制。</p>
<p>#3.特性</p>
<p>1&gt; 主线程的RunLoop在应用启动的时候就会自动创建<br>2&gt; 其他线程则需要在该线程下自己启动<br>3&gt; 不能自己创建RunLoop<br>4&gt; RunLoop并不是线程安全的，所以需要避免在其他线程上调用当前线程的RunLoop<br>5&gt; RunLoop负责管理autoreleasepools<br>6&gt; RunLoop负责处理消息事件，即输入源事件和计时器事件</p>
<p>#4.RunLoop机制</p>
<p>主线程 (有 RunLoop 的线程) 几乎所有函数都从以下六个之一的函数调起:</p>
<p>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION<br>CFRunloop is calling out to an abserver callback function<br>用于向外部报告 RunLoop 当前状态的更改，框架中很多机制都由 RunLoopObserver 触发，如 CAAnimation</p>
<p>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK<br>CFRunloop is calling out to a block<br>消息通知、非延迟的perform、dispatch调用、block回调、KVO</p>
<p>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE<br>CFRunloop is servicing the main desipatch queue</p>
<p>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION<br>CFRunloop is calling out to a timer callback function<br>延迟的perform, 延迟dispatch调用</p>
<p>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION<br>CFRunloop is calling out to a source 0 perform function<br>处理App内部事件、App自己负责管理（触发），如UIEvent、CFSocket。普通函数调用，系统调用</p>
<p>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION<br>CFRunloop is calling out to a source 1 perform function<br>由RunLoop和内核管理，Mach port驱动，如CFMachPort、CFMessagePort</p>
<p>#5.RunLoop 架构</p>
<p>#RunLoop 原理和核心机制</p>
<p>RunLoop主要有以下六种状态：</p>
<p>kCFRunLoopEntry – 进入runloop循环<br>kCFRunLoopBeforeTimers – 处理定时调用前回调<br>kCFRunLoopBeforeSources – 处理input sources的事件<br>kCFRunLoopBeforeWaiting – runloop睡眠前调用<br>kCFRunLoopAfterWaiting – runloop唤醒后调用<br>kCFRunLoopExit – 退出runloop<br>RunLoop 运行时调用栈</p>
<p>#主线程App运行时<br>RunLoop 原理和核心机制</p>
<p>RunLoopObserver与Autorelease Pool的关系<br>UIKit 通过 RunLoopObserver 在 RunLoop 两次 Sleep 间对 Autorelease Pool 进行 Pop 和 Push 将这次 Loop 中产生的 Autorelease 对象释放。</p>
<p>#RunLoop的挂起与唤醒</p>
<p>指定用于唤醒的 mach_port 端口<br>调用 mach_msg 监听唤醒端口，被唤醒前系统内核将这个线程挂起，停留在mach_msg_trap状态。<br>由另一个线程向内核发送这个端口的msg后，trap状态被唤醒，RunLoop继续工作。<br>RunLoop支持的消息事件(Events)</p>
<p>支持接收处理输入源（Input Source）事件，包括：<br>系统的Mach Port事件，是一种通讯事件<br>自定义输入事件<br>支持接受处理定时源（Timer）事件</p>
<p>在启动RunLoop之前，必须添加监听的输入源事件或者定时源事件，否则调用[runloop run]会直接返回，而不会进入循环让线程长驻。</p>
<p>如果没有添加任何输入源事件或Timer事件，线程会一直在无限循环空转中，会一直占用CPU时间片，没有实现资源的合理分配。<br>没有while循环且没有添加任何输入源或Timer的线程，线程会直接完成，被系统回收。</p>
<p>//错误做法<br>NSRunLoop *runLoop = [NSRunLoop currentRunLoop];<br>while (!self.isCancelled &amp;&amp; !self.isFinished) {<br>    [runLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]];<br>};</p>
<p>//正确做法<br>NSRunLoop *runLoop = [NSRunLoop currentRunLoop];<br>[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];<br>while (!self.isCancelled &amp;&amp; !self.isFinished) {<br>    @autoreleasepool {<br>        [runLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]];<br>    }<br>}<br>Run Loop Modes</p>
<p>#理解<br>Run Loop Mode就是流水线上支持生产的产品类型，流水线在一个时刻只能在一种模式下运行，生产某一类型的产品。消息事件就是订单。</p>
<p>Cocoa定义了如下五种Mode</p>
<p>Default：NSDefaultRunLoopMode，默认模式，在Run Loop没有指定Mode的时候，默认就跑在Default Mode下<br>Connection：NSConnectionRunLoopMode，用来监听处理网络请求NSConnection的事件<br>Modal：NSModalPanelRunLoopMode，OSX的Modal面板事件<br>Event tracking：UITrackingRunLoopMode，拖动事件<br>Common mode：NSRunLoopCommonModes，是一个模式集合，当绑定一个事件源到这个模式集合的时候就相当于绑定到了集合内的每一个模式</p>
<p>RunLoop可以通过[acceptInputForMode:beforeDate:]和[runMode:beforeDate:]来指定在一段时间内的运行模式。如果不指定的话，RunLoop默认会运行在Default下（不断重复调用runMode:NSDefaultRunLoopMode beforDate:）</p>
<p>#在主线程启动一个计时器,拖动UITableView或者UIScrollView，计时器不执行的原因和解决方案<br>在主线程启动一个计时器Timer，然后拖动UITableView或者UIScrollView，计时器不执行。这是因为，为了更好的用户体验，在主线程中Event tracking模式的优先级最高。在用户拖动控件时，主线程的Run Loop是运行在Event tracking Mode下，而创建的Timer是默认关联为Default Mode，因此系统不会立即执行Default Mode下接收的事件。解决方法：</p>
<p>NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1.0<br>                                                   target:self<br>                                                 selector:@selector(timerFireMethod:)<br>                                                 userInfo:nil<br>                                                  repeats:YES];</p>
<p>[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];<br>//或<br>[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</p>
<p>[timer fire];</p>
<p>#Run Loop应用实践</p>
<p>Run Loop主要有以下三个应用场景：</p>
<p>#1.维护线程的生命周期，让线程不自动退出，isFinished为Yes时退出。<br>NSRunLoop <em>runLoop = [NSRunLoop currentRunLoop];<br>[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];<br>while (!self.isCancelled &amp;&amp; !self.isFinished) {<br>    @autoreleasepool {<br>            [runLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]];<br>    }<br>}<br>创建常驻线程，执行一些会一直存在的任务。该线程的生命周期跟App相同<br>@autoreleasepool {<br>        NSRunLoop </em>runLoop = [NSRunLoop currentRunLoop];<br>        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];<br>        [runLoop run];<br>}</p>
<p>#2.在一定时间内监听某种事件，或执行某种任务的线程<br>如下代码，在30分钟内，每隔30s执行onTimerFired:。这种场景一般会出现在，如我需要在应用启动之后，在一定时间内持续更新某项数据。<br>@autoreleasepool {<br>    NSRunLoop <em> runLoop = [NSRunLoop currentRunLoop];<br>    NSTimer </em> udpateTimer = [NSTimer timerWithTimeInterval:30<br>                                                    target:self<br>                                                  selector:@selector(onTimerFired:)<br>                                                  userInfo:nil<br>                                                   repeats:YES];<br>    [runLoop addTimer:udpateTimer forMode:NSRunLoopCommonModes];<br>    [runLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:60*30]];<br>}</p>
<p>#3.AFNetworking中RunLoop的创建</p>
<ul>
<li><p>(void)networkRequestThreadEntryPoint:(id)__unused object {<br>  @autoreleasepool {</p>
<pre><code>[[NSThread currentThread] setName:@&quot;AFNetworking&quot;];

NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
 // 这里主要是监听某个 port，目的是让这个 Thread 不会回收
[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; 
[runLoop run];
</code></pre><p>  }<br>}</p>
</li>
<li><p>(NSThread <em>)networkRequestThread {<br>  static NSThread </em>_networkRequestThread = nil;<br>  static dispatch_once_t oncePredicate;<br>  dispatch_once(&amp;oncePredicate, ^{</p>
<pre><code>_networkRequestThread =
[[NSThread alloc] initWithTarget:self
                        selector:@selector(networkRequestThreadEntryPoint:)
                          object:nil];
[_networkRequestThread start];
</code></pre><p>  });<br>  return _networkRequestThread;<br>}</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/13/分享/" itemprop="url">
                  高效工具资源及分享
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-13T19:32:17+08:00" content="2015-11-13">
              2015-11-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高效工具资源及分享"><a href="#高效工具资源及分享" class="headerlink" title="高效工具资源及分享"></a>高效工具资源及分享</h1><p>Github-iOS代码备忘</p>
<p>非常详尽的归纳整理了Github各种IOS相关的代码<br> <a href="http://github.ibireme.com/github/list/ios/" target="_blank" rel="external">Github地址</a></p>
<p>生成PNG图标的工具</p>
<p>可以根据需求对应@2X，@3X的尺寸生成对应的图标，平时用这个比较多，快速高效。<br><a href="http://iconion.com" target="_blank" rel="external">生成PNG图标的工具</a><br>CocoaPods插件cocoapods-xcode-plugin</p>
<p>我很不喜欢用终端设置CocoaPods，所以站在巨人的肩膀上用了这个插件，非常好用哦!<br><a href="https://github.com/kattrali/cocoapods-xcode-plugin" target="_blank" rel="external">https://github.com/kattrali/cocoapods-xcode-plugin</a></p>
<p>“快速写代码注释的插件VVDocumenter-Xcode</p>
<p>平时经常使用的，有些依赖她了。<br><a href="https://github.com/onevcat/VVDocumenter-Xcode”" target="_blank" rel="external">https://github.com/onevcat/VVDocumenter-Xcode”</a></p>
<p>快速建模工具ESJsonFormat-Xcode</p>
<p>很强悍哦！将JSON格式化输出为模型的属性，还能生成生成的 MJExtension框架中objectClassInArray方法(类方法)<br><a href="https://github.com/EnjoySR/ESJsonFormat-Xcode" target="_blank" rel="external">https://github.com/EnjoySR/ESJsonFormat-Xcode</a></p>
<p>“录制Demo演示GIF的工具</p>
<p>MAButtonTool是一个快速创建按钮的工具类<br><a href="https://github.com/MISSAJJ/MAButtonTool”" target="_blank" rel="external">https://github.com/MISSAJJ/MAButtonTool”</a></p>
<p>“Mac上优秀的HTTP监视器和抓包工具Charles</p>
<p>1、Charles介绍<br>Charles（青花瓷）是一款Mac上的HTTP代理服务器、HTTP监视器、反向代理服务器，可以让开发者监视查看所有连接互联网的HTTP通信，包括请求，响应和HTTP头信息等等，俗称“抓包”工具，对于Web开发人员来说是一款很有价值的辅助工具！”</p>
<p>2、“使用很简单，MAC连上苹果手机，手机设置好和MAC相同的IP，然后打开Charles，之后就可以抓到手机打开的任何APP的API数据交互，基本上大部分的APP都能抓到包。（淘宝官方APP除外，淘宝太牛了，貌似都加了密，如果有大神知道如何能抓包到淘宝官方APP的API数据，欢迎前来指点！）”</p>
<p>“<a href="http://www.waitsun.com/?s=charles”" target="_blank" rel="external">http://www.waitsun.com/?s=charles”</a></p>
<p>“MAC上翻墙软件-Lantern蓝灯</p>
<p>如果你不喜欢看英文网站，或者不知道翻墙，那就跳过吧，找度娘查资料也能查到很多中文资料的。<br>如果经常要去看被祖国已经和谐了的国外网站，比如YouTube，Facebook，Twitter等，可以用这个Lantern蓝灯。”</p>
<p>链接: “<a href="http://pan.baidu.com/s/1kUSjGZ9" target="_blank" rel="external">http://pan.baidu.com/s/1kUSjGZ9</a> 密码: x9x1”</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/12/地图定位CoreLocation框架的使用(2)/" itemprop="url">
                  地图定位CoreLocation框架的使用(2)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-12T02:04:11+08:00" content="2015-07-12">
              2015-07-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CoreLocation框架"><a href="#CoreLocation框架" class="headerlink" title="CoreLocation框架"></a>CoreLocation框架</h1><p>#四. CLLocation对象详解 </p>
<p>#1. 属性解释</p>
<pre><code>    &gt; coordinate
&gt; altitude
&gt; speed
&gt; course
</code></pre><p>#2. 重要方法<br>: 当前位置所在的经纬度数据<br>: 海拔<br>: 当前速度<br>: 航向(设备移动的方向, 值域范围:0.0 ~ 259.9, 正北方向为0.0)<br>代码: - (CLLocationDistance)distanceFromLocation:(CLLocation *)location 作用: 计算两个位置对象之间的物理距离, 单位是(米)</p>
<p>#3. 场景演练</p>
<ol>
<li>场景演示:打印当前用户的行走方向,偏离角度以及对应的行走距离, 例如:”北偏东30度方向,移动了8米”</li>
<li>实现步骤:<br>1&gt; 获取对应的方向偏向(例如”正东”,”东偏南”) 2&gt; 获取对应的偏离角度(并判断是否是正方向) 3&gt; 计算行走距离<br>4&gt; 打印信息<br>#4. 注意事项<br>使用位置前, 务必判断当前获取的位置是否有效<br>代码: if (location.horizontalAccuracy &lt; 0) return;<br>功能: 如果水平精确度小于零, 代表虽然可以获取位置对象, 但是数据错误, 不可用<br>#五、经验小结<br>#一. 定位的应用场景<br>1) 导航<br>2) 电商APP,获取用户所在城市(需要与(反)地理编码联合使用) 3) 数据采集用户信息(例如,统计app使用分布)<br>4) 查找周边(周边好友, 周边商家等等)<br>Chapter-19(II)地图定位CoreLocation框架 142<br>MISSAJJ IOSDevelopment GitBook<h1 id="二-开发经验"><a href="#二-开发经验" class="headerlink" title="二. 开发经验"></a>二. 开发经验</h1>#1. 由于定位非常耗电; 所以为了给用户省电, 你可以遵守以下小经验<br>1)不需要获取用户位置时,一定要关闭定位服务: 2)如果能满足项目需求,尽可能的使用”监听显著位置变化”的定位服务(打车app) 3)如果可以,尽可能使用低精度的desiredAccuracy 4)如果是数据采集,(一般都是周期性的去轮询用户位置),在轮询期间一定要关闭定位<br>五. 指南针效果实现 1. 实现思路<br>利用”磁力计”传感器,获取设备朝向 根据设备朝向反向旋转”指南针”图片<br>#2. 代码实现<br>获取设备朝向<br>1) 导入CoreLocation框架以及对应的主头文件 #import <corelocation corelocation.h=""><br>2) 创建CLLocationManager对象并设置代理<br>self.locationM = [[CLLocationManager alloc] init]; self.locationM.delegate = self;<br>3) 调用方法, 开始获取设备朝向<br>[self.locationM startUpdatingHeading];<br>4) 在对应的代理方法中获取设备朝向信息 -(void)locationManager:(CLLocationManager <em>)manager didUpdateHeadi<br>{<br>// 旋转图片代码<br>} 旋转图片<br>// 1.判断当前的角度是否有效(如果此值小于0,代表角度无效) if(newHeading.headingAccuracy &lt; 0)<br>return;<br>// 2.获取当前设备朝向(磁北方向)<br>CGFloat angle = newHeading.magneticHeading;<br>// 3.转换成为弧度<br>CGFloat radian = angle / 180.0 </em> M_PI;<br>// 4.带动画反向旋转指南针<br>[UIView animateWithDuration:0.5 animations:^{<pre><code>    self.compassView.transform = CGAffineTransformMakeRotation(-radian
}];
</code></pre>)</corelocation></li>
<li>概念补充<br>磁北角度: newHeading.magneticHeading 真北角度: newHeading.trueHeading</li>
<li>注意事项<br>——- 相对于”磁北方向”产生的角度 ——- 相对于”真北方向”产生的角度</li>
<li>获取设备朝向前, 先判断”磁力计”是否可用 [CLLocationManager headingAvailable];</li>
<li>获取朝向前, 判断当前朝向信息是否有效 if(newHeading.headingAccuracy &lt; 0) return;</li>
<li>注意与”航向”的区别<br>设备朝向是指手机的朝向; “航向”可以理解为设备的移动方向</li>
<li>使用”磁力计”传感器获取设备朝向, 不需要请求用户授权 因为设备朝向不涉及用户隐私<br>5.测试环境</li>
<li>XCode版本无要求(建议:XCode7.0不需要开发者账号也可以进行真机调试) 2. 必须要求真机设备(只有真机设备才有”磁力计”传感器)<br>六. 区域监听 1.概念解释<br>区 域 : 就是指划定的一块地域范围(比如圆形区域, 则由区域中心, 和半径组成)<br>区域监听 : 是指,我们通过代码指定一个区域, 然后当用户持握设备进入或者离开指定区域, 我们<br>#2. 监听指定区域<br>导入CoreLocation框架以及对应的主头文件 <corelocation corelocation.h=""><br>创建CLLocationManager对象并设置代理<pre><code>self.locationM = [[CLLocationManager alloc] init];
self.locationM.delegate = self;
</code></pre>请求前后台定位, 或前台定位授权, 并在Info.Plist文件中配置相应的Key<pre><code>[self.locationM requestAlwaysAuthorization];
// [self.locationM requestWhenInUseAuthorization];
</code></pre>创建一个区域, 并开始监听<br>// 1. 判断区域监听服务是否可用(定位服务是否关闭, 定位是否授权, 是否开启飞行模式) if ([CLLocationManager isMonitoringAvailableForClass:[CLCircularRegion {<br>// 创建区域中心<br>CLLocationCoordinate2D center = CLLocationCoordinate2DMake(29.1234<br>// 创建区域(指定区域中心,和区域半径) CLLocationDistance radius = 1000;<br>// 判断区域半径是否大于最大监听区域半径,如果大于, 就没法监听<br>if (radius &gt; self.locationM.maximumRegionMonitoringDistance) {<pre><code>    radius = self.locationM.maximumRegionMonitoringDistance;
}
CLCircularRegion *region = [[CLCircularRegion alloc] initWithCente
</code></pre>// 开始监听指定区域<pre><code>    [self.locationM startMonitoringForRegion:region];
}
</code></pre>else<br>{<br>NSLog(@”区域监听不可用”);<br>}<br>在对应的代理方法中监听区域状态<br>// 进去监听区域后调用(调用一次)<br>-(void)locationManager:(nonnull CLLocationManager <em>)manager didEnterRe<br>{<br>NSLog(@”进入区域—%@”, region.identifier); [manager stopMonitoringForRegion:region];<br>}<br>// 离开监听区域后调用(调用一次)<br>-(void)locationManager:(nonnull CLLocationManager </em>)manager didExitReg<br>{<br>NSLog(@”离开区域—%@”, region.identifier);<br>}<br>#3. 获取某个区域的当前状态<br>监听某个区域时, 只有进入或者离开这个区域时, 才能回调对应的方法, 是一个进入或者离开的 动作 如果想知道某一个区域的当前状态(识别用户是在区域内部, 还是区域外部), 则需要使用以 下方法<br>代 码:<br>[self.locationM requestStateForRegion:region];<br>回调代理:<br>// 请求某个区域状态时, 回调的代理方法 -(void)locationManager:(CLLocationManager *)manager didDetermineState:(CL<br>{<br> switch (state) {<br>case CLRegionStateUnknown: NSLog(@”未知状态”); break;<br>case CLRegionStateInside: NSLog(@”在区域内部”);<br>Chapter-19(II)地图定位CoreLocation框架 145<br>5<br>r<br>g<br>i<br>R<br>MISSAJJ IOSDevelopment GitBook<pre><code>     break;
case CLRegionStateOutside:
</code></pre>NSLog(@”在区域外部”);<pre><code>    break;
default:
</code></pre>break; }<br>}<br>#4. 测试环境<br>XCode版本无要求 iOS模拟器版本无要求 5. 注意事项</corelocation></li>
<li>想要做区域监听, 在iOS8.0之后, 必须请求位置授权<br>代码: [self.locationM requestAlwaysAuthorization];<br>原因: 区域监听的原理就是获取用户的位置, 然后在判断该位置是否在制定区域内, 所以会涉及到用</li>
<li>使用前, 先判断区域监听是否可用<br>代码: [CLLocationManager isMonitoringAvailableForClass:[CLCircularRegion c</li>
<li>注意区域半径是否大于最大区域监听半径(如果大于, 则无法监听成功)<br>代码: radius &gt; self.locationM.maximumRegionMonitoringDistance<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1></li>
<li>区域监听, 测试没有效果?<br>首先, 确定代码没有问题, 是否有请求授权;<br>其次, 尝试修改模拟器位置信息, 触发进入区域或离开区域的动作<br>第三, 如果模拟器出现BUG, 定位不到, 也会无法判定当前区域状态; 所以, 最后可以尝试重置模<br>#地理编码<br>#1. 概念解释<br>地理编码: 是指根据地址关键字, 将其转换成为对应的经纬度等信息; 发地理编码: 是指根据经纬度信息, 将其转换成为对应的省市区街道等信息;<br>#2. 地理编码<br>导入CoreLocation框架以及对应的主头文件 #import <corelocation corelocation.h=""><br>创建CLGeocoder对象<br>self.geoC = [[CLGeocoder alloc] init];<br>根据地址关键字, 进行地理编码<br>// 直接根据地址进行地理编码(返回结果可能有多个,因为一个地点有重名)<br> Chapter-19(II)地图定位CoreLocation框架 146<br>拟<br>MISSAJJ IOSDevelopment GitBook<br>[self.geoC geocodeAddressString:@”广州” completionHandler:^(NSArray&lt;CL<br>{<br>// 包含区,街道等信息的地标对象<br>CLPlacemark <em>placemark = [placemarks firstObject]; // 城市名称<br>NSString </em>city = placemark.locality;<br>// 街道名称<br>NSString <em>street = placemark.thoroughfare;<br>// 全称<br>NSString </em>name = placemark.name;<br>}]; </corelocation></li>
<li>反地理编码<br>导入CoreLocation框架以及对应的主头文件<corelocation corelocation.h=""><br>创建CLGeocoder对象<br>self.geoC = [[CLGeocoder alloc] init];<br>根据经纬度信息, 进行反地理编码<br>// 根据经纬度信息进行反地理编码<br>[self.geoC reverseGeocodeLocation:[[CLLocation alloc] initWithLatitude<br>{<br>// 包含区,街道等信息的地标对象<br>CLPlacemark <em>placemark = [placemarks firstObject]; // 城市名称<br>NSString </em>city = placemark.locality;<br>// 街道名称<br>NSString <em>street = placemark.thoroughfare;<br>// 全称<br>NSString </em>name = placemark.name;<br>}];</corelocation></li>
<li>CLPlacemark 地标对象详解<br>location : CLLocation 类型, 位置对象信息, 里面包含经纬度, 海拔等等 region : CLRegion 类型, 地标对象对应的区域<br>addressDictionary : NSDictionary 类型, 存放街道,省市等信息<br>: NSString 类型, 地址全称 : NSString 类型, 街道名称 : NSString 类型, 城市名称<br>name<br>thoroughfare<br>locality<br>administrativeArea : NSString 类型, 省名称 country : NSString 类型, 国家名称<h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境```"></a>测试环境```</h1>必须联网 XCode版本不限 iOS模拟器系统版本不限 ```<h1 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h1>测试无数据?<br>首先, 检查是否有联网;<br>其次, 如果是反地理编码,可尝试更换经纬度再次尝试, 有的经纬度没有对应信息<br>#1. 应用场景<br>一般与定位结合使用, 确定当前位置的具体地理信息<br>八. 使用第三方框架进行定位<br>#1. 主要原因<br>因为使用CoreLocation框架进行获取用户位置信息, 是通过代理进行回调; 而第三方框架<br>#2. 框架信息<br>名称: locationManager<br>地址: <a href="https://github.com/intuit/LocationManager" target="_blank" rel="external">link</a><br>#3. 使用方法 参照该框架对应的 readME<br>#4. 注意事项<br>一般集成第三方框架到项目中, 请先确保该框架没有问题, 然后再向项目中集成</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/11/地图定位CoreLocation框架的使用(1)/" itemprop="url">
                  地图定位CoreLocation框架的使用(1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-11T23:04:11+08:00" content="2015-07-11">
              2015-07-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CoreLocation框架"><a href="#CoreLocation框架" class="headerlink" title="CoreLocation框架"></a>CoreLocation框架</h1><h1 id="一-IOS8-0之前的定位"><a href="#一-IOS8-0之前的定位" class="headerlink" title="一:IOS8.0之前的定位"></a>一:IOS8.0之前的定位</h1><p>#1. 前台定位<br>导入CoreLocation框架以及对应的主头文件 <corelocation corelocation.h=""><br>创建CLLocationManager对象并设置代理<br>       self.locationM = [[CLLocationManager alloc] init];<br>       self.locationM.delegate = self;<br>调用方法,开始更新用户位置信息<br>[self.locationM startUpdatingLocation];<br>  在对应的代理方法中获取位置信息<br>       -(void)locationManager:(nonnull CLLocationManager *)manager didUpdateL<br>{<br>NSLog(@”每当请求到位置信息时, 都会调用此方法”);<br>}</corelocation></p>
<p>#2. 后台定位<br>在前台定位基础上, 勾选后台模式Location updates image</p>
<p>#3. 额外设置</p>
<p>每隔多少米定位一次<br>代码: self.locationM.distanceFilter = 100;<br>功能: 只有当最新的位置与上一次获取的位置之间的距离, 大于这个值时, 才会通过代理告诉外界<br>设置定位精确度<br>代 码: self.locationM.desiredAccuracy = kCLLocationAccuracyBest; 功 能: 通过设置此属性, 获取不同精确度的位置信息<br>注意事项: 精确度越高,越耗电,定位所需时间越长<br>枚举注解:<br>  枚举值 kCLLocationAccuracyBestForNavigation<br>kCLLocationAccuracyBest kCLLocationAccuracyNearestTenMeters kCLLocationAccuracyHundredMeters kCLLocationAccuracyKilometer kCLLocationAccuracyThreeKilometers</p>
<ol>
<li>知识补充<br>含义<br>最适合导航<br>精度最好的<br>附近10米 附近100米 附近1000米 附近3000米</li>
<li>定位常识<br>1) 标准定位服务(基于gps/基站/wifi定位, 具体使用哪种,苹果有自己规则)<blockquote>
<p>程序关闭,就没法获取位置<br>2) 显著的位置变化定位服务(使用基站进行定位,所以必须要求设备有电话模块)<br>当app被完全关闭时,也可以接收到位置通知,并让app进入到后台处理<br>定位精度相比于上面,精度不大,所以耗电小,而且定位更新频率依据基站密度而定</p>
</blockquote>
</li>
<li>应用场景<br>1) 如果要求定位及时,精度较高,并且运行时间较短,可使用标准定位;<br>2) 如果长时间监控用户位置,用户移动速度比较快(例如打车软件),可使用后者<br>#4. 测试环境:</li>
<li>XCode7.0之前版本,例如XCode6.4版本 2. 模拟器选择iOS8.0之前的版本</li>
</ol>
<ul>
<li>原因 : XCode7.0(包含7.0)之后不支持iOS8.0之前的模拟器<br>#5.常见问题总结<br>定位不到, 对应的代理方法不执行:<br>首先,检查运行的模拟器是否是iOS8.0之前的系统版本<br>其次,检查模拟器是否设置位置数据 第三,确保代码无问题(一般都是代理没有设置,或者位置管理器对象是局部变量,亦或是位置管理器 第四,绝逼是模拟器BUG, 请重置模拟器(是重置,不是重启)<br>#二. iOS8.0之后定位<br>#1. 前台定位<br>导入CoreLocation框架以及对应的主头文件 <corelocation corelocation.h=""><br>创建CLLocationManager对象并设置代理<pre><code>self.locationM = [[CLLocationManager alloc] init];
self.locationM.delegate = self;
</code></pre>请求前台定位授权, 并在Info.Plist文件中配置Key ( Nslocationwheninuseusagedescription ) [self.locationM requestWhenInUseAuthorization];<br>调用方法,开始更新用户位置信息<br>[self.locationM startUpdatingLocation];<br>在对应的代理方法中获取位置信息<pre><code>-(void)locationManager:(nonnull CLLocationManager *)manager didUpdateL
</code></pre>{<br>NSLog(@”每当请求到位置信息时, 都会调用此方法”);<br>}<br>#2. 后台定位<br>方案一:<br>在前台定位基础上, 勾选后台模式Location updates</corelocation></li>
</ul>
<p>方案二:<br>请求前后台定位授权,并在info.plist文件中配置KEY ( NSLocationAlwaysUsageDescription ) [self.locationM requestAlwaysAuthorization];<br>注意:不需要勾选后台模式, 也可以进行后台定位<br>注意:此时授权状态如果是前后台定位, 那么即使APP退到后台时, 屏幕顶部会也不会出现 蓝条</p>
<p>#3. 监听用户授权状态<br>实现以下代理方法即可<br>// 当用户授权状态发生变化时调用<br>-(void)locationManager:(nonnull CLLocationManager <em>)manager didChangeA {<br>switch (status) {<br>// 用户还未决定<br>case kCLAuthorizationStatusNotDetermined:<br>{<br>NSLog(@”用户还未决定”);<br>break; }<br>// 访问受限(苹果预留选项,暂时没用)<br>case kCLAuthorizationStatusRestricted:<br>{<br>NSLog(@”访问受限”); break;<br>}<br>// 定位关闭时和对此APP授权为never时调用<br> case kCLAuthorizationStatusDenied: {<br>// 定位是否可用(是否支持定位或者定位是否开启) if([CLLocationManager locationServicesEnabled])<br>{<br>NSLog(@”定位开启,但被拒”);<br>// 在此处, 应该提醒用户给此应用授权, 并跳转到”设置”界面让用户进行授权<br>// 在iOS8.0之后跳转到”设置”界面代码<br>NSURL </em>settingURL = [NSURL URLWithString:UIApplicationOpenSett if([[UIApplication sharedApplication] canOpenURL:settingURL]) {<br>                   [[UIApplication sharedApplication] openURL:settingURL];<br>      }<br>}else<br>{<br>NSLog(@”定位关闭,不可用”);<br>}<br>break; }<br>// 获取前后台定位授权<br>case kCLAuthorizationStatusAuthorizedAlways:<br>// case kCLAuthorizationStatusAuthorized: // 失效,不建议使用 {<br>NSLog(@”获取前后台定位授权”); break;<br>}<br>// 获得前台定位授权<br>       case kCLAuthorizationStatusAuthorizedWhenInUse:<br>{<br>NSLog(@”获得前台定位授权”); break;<br>} default:<br>break; }<br>}</p>
<p>#5. 常见问题总结<br>定位不到, 对应的代理方法不执行:<br>首先,检查是否请求授权, 并设置了对应的KEY<br>其次,检查模拟器是否设置位置数据 第三,确保代码无问题(一般都是代理没有设置,或者位置管理器对象是局部变量,亦或是位置管理器 第四,前面都不对那就是模拟器BUG, 请重置模拟器(是重置,不是重启)</p>
<p>#三. iOS9.0 定位补充 </p>
<p>#1. 定位变化<br>前台定位<br>(同iOS8.0之后一致, 无任何变化, 都需要主动请求授权)<br>后台定位 方案一:<br>在前台定位基础上, 勾选后台模式Location updates, 并且设置以下属性为YES<br>     if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 9.0)<br>      {<br>          self.locationM.allowsBackgroundLocationUpdates = YES;<br>      }<br>方案二:<br>请求前后台定位授权,并在info.plist文件中配置KEY ( NSLocationAlwaysUsageDescription<br>[self.locationM requestAlwaysAuthorization]; </p>
<p>#2. 新的API<br>单次定位请求;<br>代 码: [self.locationM requestAlwaysAuthorization]; 功 能: 获取一次位置信息<br>实现逻辑:<br>(1) 按照定位精确度从低到高进行排序,逐个进行定位.如果在有效时间内, 定位到了精<br>(2) 如果获取到的位置不是精确度最高的那个,也会在定位超时后,通过代理告诉外界. 注意事项:<br>(1) 必须实现代理的-locationManager:didFailWithError:方法 (2) 不能与startUpdatingLocation方法同时使用</p>
<p>#3. 测试环境:</p>
<ol>
<li>XCode版本要求7.0版本以上 2. 模拟器选择iOS9.0之后的版本<br>#4. 常见问题总结<br>单次定位在模拟器上测试不出效果?<br>答: 因为模拟器的位置是固定的, 所以无法测试出效果, 请使用真机进行测试.</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/11/优化UITableViewCell高度计算(转)/" itemprop="url">
                  优化UITableViewCell高度计算(转)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-11T10:51:17+08:00" content="2015-07-11">
              2015-07-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#本文是关于 UITableViewCell 利用 AutoLayout 自动高度计算和 UITableView 滑动优化的一个总结。</p>
<p>#本文作者维护的UITableView+FDTemplateLayoutCell框架，让高度计算这个事情变的前所未有的简单  地址:<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a></p>
<p>#本文主要内容</p>
<ol>
<li>UITableView高度计算和估算的机制</li>
<li>不同iOS系统在高度计算上的差异</li>
<li>iOS8 self-sizing cell</li>
<li>UITableView+FDTemplateLayoutCell如何用一句话解决高度问题</li>
<li>UITableView+FDTemplateLayoutCell中对RunLoop的使用技巧</li>
</ol>
<p>#UITableViewCell高度计算</p>
<p>#核心关键词:rowHeight</p>
<p>UITableView是我们再熟悉不过的视图了，它的 delegate 和 data source 回调不知写了多少次，也不免遇到 UITableViewCell 高度计算的事。UITableView 询问 cell 高度有两种方式。<br>一种是针对所有 Cell 具有固定高度的情况，通过：</p>
<p>#self.tableView.rowHeight = 88;</p>
<p>上面的代码指定了一个所有 cell 都是 88 高度的 UITableView，对于定高需求的表格，强烈建议使用这种（而非下面的）方式保证不必要的高度计算和调用。rowHeight属性的默认值是 44，所以一个空的 UITableView 显示成那个样子。</p>
<p>#另一种方式就是实现 UITableViewDelegate 中的：</p>
<ul>
<li>(CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath {<br>  // return xxx<br>}<br>需要注意的是，实现了这个方法后，rowHeight 的设置将无效。所以，这个方法适用于具有多种 cell 高度的 UITableView。</li>
</ul>
<p>#核心关键词:estimatedRowHeight</p>
<p>这个属性 iOS7 就出现了， 文档是这么描述它的作用的：</p>
<p>If the table contains variable height rows, it might be expensive to calculate all their heights when the table loads. Using estimation allows you to defer some of the cost of geometry calculation from load time to scrolling time.</p>
<p>恩，听上去蛮靠谱的。我们知道，UITableView 是个 UIScrollView，就像平时使用 UIScrollView 一样，加载时指定 contentSize 后它才能根据自己的 bounds、contentInset、contentOffset 等属性共同决定是否可以滑动以及滚动条的长度。而 UITableView 在一开始并不知道自己会被填充多少内容，于是询问 data source 个数和创建 cell，同时询问 delegate 这些 cell 应该显示的高度，这就造成它在加载的时候浪费了多余的计算在屏幕外边的 cell 上。和上面的 rowHeight 很类似，设置这个估算高度有两种方法：</p>
<p>self.tableView.estimatedRowHeight = 88;<br>// or</p>
<ul>
<li>(CGFloat)tableView:(UITableView <em>)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath </em>)indexPath {<br>  // return xxx<br>}</li>
</ul>
<hr>
<p>有所不同的是，即使面对种类不同的 cell，我们依然可以使用简单的 estimatedRowHeight 属性赋值，只要整体估算值接近就可以，比如大概有一半 cell 高度是 44， 一半 cell 高度是 88， 那就可以估算一个 66，基本符合预期。</p>
<p>说完了估算高度的基本使用，可以开始吐槽了：</p>
<ol>
<li><p>设置估算高度后，contentSize.height 根据“cell估算值 x cell个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。</p>
</li>
<li><p>若是有设计不好的下拉刷新或上拉加载控件，或是 KVO 了 contentSize 或 contentOffset 属性，有可能使表格滑动时跳动。</p>
</li>
<li><p>估算高度设计初衷是好的，让加载速度更快，那凭啥要去侵害滑动的流畅性呢，用户可能对进入页面时多零点几秒加载时间感觉不大，但是滑动时实时计算高度带来的卡顿是明显能体验到的，个人觉得还不如一开始都算好了呢（iOS8更过分，即使都算好了也会边划边计算）</p>
</li>
</ol>
<p>#iOS8 self-sizing cell</p>
<p>具有动态高度内容的 cell 一直是个头疼的问题，比如聊天气泡的 cell， frame 布局时代通常是用数据内容反算高度：</p>
<p>CGFloat height = textHeightWithFont() + imageHeight + topMargin + bottomMargin + …;</p>
<h2 id="供-UITableViewDelegate-调用时很可能是个-cell-的类方法："><a href="#供-UITableViewDelegate-调用时很可能是个-cell-的类方法：" class="headerlink" title="供 UITableViewDelegate 调用时很可能是个 cell 的类方法："></a>供 UITableViewDelegate 调用时很可能是个 cell 的类方法：</h2><p>@interface BubbleCell : UITableViewCell</p>
<ul>
<li>(CGFloat)heightWithEntity:(id)entity;<h2 id="end"><a href="#end" class="headerlink" title="@end"></a>@end</h2></li>
</ul>
<p>各种魔法 margin 加上耦合了屏幕宽度。</p>
<p>AutoLayout 时代好了不少，提供了-systemLayoutSizeFittingSize:的 API，在 contentView 中设置约束后，就能计算出准确的值；缺点是计算速度肯定没有手算快，而且这是个实例方法，需要维护专门为计算高度而生的 template layout cell，它还要求使用者对约束设置的比较熟练，要保证 contentView 内部上下左右所有方向都有约束支撑，设置不合理的话计算的高度就成了0。</p>
<p>这里还不得不提到一个 UILabel 的蛋疼问题，当 UILabel 行数大于0时，需要指定 preferredMaxLayoutWidth 后它才知道自己什么时候该折行。这是个“鸡生蛋蛋生鸡”的问题，因为 UILabel 需要知道 superview 的宽度才能折行，而 superview 的宽度还依仗着子 view 宽度的累加才能确定。这个问题好像到 iOS8 才能够自动解决（不过我们找到了解决方案）</p>
<p>回到正题，iOS8 WWDC 中推出了 self-sizing cell 的概念，旨在让 cell 自己负责自己的高度计算，使用 frame layout 和 auto layout 都可以享受到：</p>
<p>#这个特性首先要求是 iOS8，要是最低支持的系统版本小于8的话，还得针对老版本单写套老式的算高（囧），不过用的 API 到不是新面孔：</p>
<p>self.tableView.estimatedRowHeight = 213;<br>self.tableView.rowHeight = UITableViewAutomaticDimension;</p>
<p>这里又不得不吐槽了，自动计算 rowHeight 跟 estimatedRowHeight 到底是有什么仇，如果不加上估算高度的设置，自动算高就失效了- -<br>PS：iOS8 系统中 rowHeight 的默认值已经设置成了 UITableViewAutomaticDimension，所以第二行代码可以省略。</p>
<p>问题：<br>这个自动算高在 push 到下一个页面或者转屏时会出现高度特别诡异的情况，不过现在的版本修复了。<br>iOS8抽风的算高机制</p>
<p>相同的代码在 iOS7 和 iOS8 上滑动顺畅程度完全不同，iOS8 莫名奇妙的卡。很大一部分原因是 iOS8 上的算高机制大不相同，这是我做的小测试：</p>
<p>#研究后发现这么多次额外计算有下面的原因：</p>
<p>不开启高度估算时，UITableView 上来就要对所有 cell 调用算高来确定 contentSize<br>dequeueReusableCellWithIdentifier:forIndexPath: 相比不带 “forIndexPath” 的版本会多调用一次高度计算<br>iOS7 计算高度后有”缓存“机制，不会重复计算；而 iOS8 不论何时都会重新计算 cell 高度<br>iOS8 把高度计算搞成这个样子，从 WWDC 也倒是能找到点解释，cell 被认为随时都可能改变高度（如从设置中调整动态字体大小），所以每次滑动出来后都要重新计算高度。</p>
<p>说了这么多，究竟有没有既能省去算高烦恼，又能保证顺畅的滑动，还能支持 iOS6+ 的一站式解决方案呢？</p>
<p>UITableView+FDTemplateLayoutCell</p>
<p>#框架使用介绍<br>使用 UITableView+FDTemplateLayoutCell 无疑是解决算高问题的最佳实践之一，既有 iOS8 self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。<br>使用起来大概是这样：</p>
<p>#import <uitableview+fdtemplatelayoutcell.h></uitableview+fdtemplatelayoutcell.h></p>
<ul>
<li>(CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath {<br>  return [tableView fd_heightForCellWithIdentifier:@”identifer” cacheByIndexPath:indexPath configuration:^(id cell) {<pre><code>// 配置 cell 的数据源，和 &quot;cellForRow&quot; 干的事一致，比如：
cell.entity = self.feedEntities[indexPath.row];
</code></pre>  }];<br>}</li>
</ul>
<p>写完上面的代码后，你就已经使用到了：</p>
<p>#1. 和每个 UITableViewCell ReuseID 一一对应的 template layout cell<br>这个 cell 只为了参加高度计算，不会真的显示到屏幕上；它通过 UITableView 的 -dequeueCellForReuseIdentifier: 方法 lazy 创建并保存，所以要求这个 ReuseID 必须已经被注册到了 UITableView 中，也就是说，要么是 Storyboard 中的原型 cell，要么就是使用了 UITableView 的 -registerClass:forCellReuseIdentifier: 或 -registerNib:forCellReuseIdentifier:其中之一的注册方法。</p>
<p>#2. 根据 autolayout 约束自动计算高度<br>使用了系统在 iOS6 就提供的 API：-systemLayoutSizeFittingSize:<br>根据 index path 的一套高度缓存机制<br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了非常可观的多余计算。</p>
<p>#3. 自动的缓存失效机制<br>无须担心你数据源的变化引起的缓存失效，当调用如-reloadData，-deleteRowsAtIndexPaths:withRowAnimation:等任何一个触发 UITableView 刷新机制的方法时，已有的高度缓存将以最小的代价执行失效。如删除一个 indexPath 为 [0:5] 的 cell 时，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。</p>
<p>#4. 预缓存机制<br>预缓存机制将在 UITableView 没有滑动的空闲时刻执行，计算和缓存那些还没有显示到屏幕中的 cell，整个缓存过程完全没有感知，这使得完整列表的高度计算既没有发生在加载时，又没有发生在滑动时，同时保证了加载速度和滑动流畅性，下文会着重讲下这块的实现原理。</p>
<p>这一套缓存机制能对滑动起多大影响呢？除了肉眼能明显的感知到外，作者还做了个小测试：</p>
<p>#一个有 54 个内容和高度不同 cell 的 table view，从头滑动到尾，再从尾滑动到头，iOS8 系统下，iPhone6，使用 Time Profiler 监测算高函数所花费的时间：</p>
<p>未使用缓存API、未使用估算，共花费 877 ms：</p>
<p>使用缓存API、开启估算，共花费 77 ms：</p>
<p>#测试数据的精度先不管，从量级上就差了一个数量级，说实话自己也没想到差距有这么大- -</p>
<p>同时，工具也顺手解决了-preferredMaxLayoutWidth的问题，在计算高度前向 contentView 加了一条和 table view 宽度相同的宽度约束，强行让 contentView 内部的控件知道了自己父 view 的宽度，再反算自己被外界约束的宽度，破除“鸡生蛋蛋生鸡”的问题，这里比较 tricky，就不展开说了。下面说说利用 RunLoop 预缓存的实现。</p>
<p>##利用RunLoop空闲时间执行预缓存任务</p>
<p>FDTemplateLayoutCell 的高度预缓存是一个优化功能，它要求页面处于空闲状态时才执行计算，当用户正在滑动列表时显然不应该执行计算任务影响滑动体验。<br>一般来说，这个功能要耦合 UITableView 的滑动状态才行，但这种实现十分不优雅且可能破坏外部的 delegate 结构，但好在我们还有RunLoop这个工具，了解它的运行机制后，可以用很简单的代码实现上面的功能。</p>
<p>##空闲RunLoopMode</p>
<p>在曾经的 RunLoop 线下分享会（视频可戳）中介绍了 RunLoopMode 的概念。<br>当用户正在滑动 UIScrollView 时，RunLoop 将切换到 UITrackingRunLoopMode 接受滑动手势和处理滑动事件（包括减速和弹簧效果），此时，其他 Mode （除 NSRunLoopCommonModes 这个组合 Mode）下的事件将全部暂停执行，来保证滑动事件的优先处理，这也是 iOS 滑动顺畅的重要原因。<br>当 UI 没在滑动时，默认的 Mode 是 NSDefaultRunLoopMode（同 CF 中的 kCFRunLoopDefaultMode），同时也是 CF 中定义的 “空闲状态 Mode”。当用户啥也不点，此时也没有什么网络 IO 时，就是在这个 Mode 下。</p>
<p>##用RunLoopObserver找准时机</p>
<p>注册 RunLoopObserver 可以观测当前 RunLoop 的运行状态，并在状态机切换时收到通知：</p>
<ol>
<li>RunLoop开始</li>
<li>RunLoop即将处理Timer</li>
<li>RunLoop即将处理Source</li>
<li>RunLoop即将进入休眠状态</li>
<li>RunLoop即将从休眠状态被事件唤醒</li>
<li>RunLoop退出</li>
</ol>
<p>因为“预缓存高度”的任务需要在最无感知的时刻进行，所以应该同时满足：</p>
<ol>
<li>RunLoop 处于“空闲”状态 Mode</li>
<li>当这一次 RunLoop 迭代处理完成了所有事件，马上要休眠时</li>
</ol>
<p>#使用 CF 的带 block 版本的注册函数可以让代码更简洁：</p>
<p>CFRunLoopRef runLoop = CFRunLoopGetCurrent();<br>CFStringRef runLoopMode = kCFRunLoopDefaultMode;<br>CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler<br>(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) {<br>    // TODO here<br>});<br>CFRunLoopAddObserver(runLoop, observer, runLoopMode);<br>在其中的 TODO 位置，就可以开始任务的收集和分发了，当然，不能忘记适时的移除这个 observer</p>
<p>##分解成多个RunLoop Source任务</p>
<p>假设列表有 20 个 cell，加载后展示了前 5 个，那么开启估算后 table view 只计算了这 5 个的高度，此时剩下 15 个就是“预缓存”的任务，而我们并不希望这 15 个计算任务在同一个 RunLoop 迭代中同步执行，这样会卡顿 UI，所以应该把它们分别分解到 15 个 RunLoop 迭代中执行，这时就需要手动向 RunLoop 中添加 Source 任务（由应用发起和处理的是 Source 0 任务）<br>Foundation 层没对 RunLoopSource 提供直接构建的 API，但是提供了一个间接的、既熟悉又陌生的 API：</p>
<ul>
<li><p>(void)performSelector:(SEL)aSelector</p>
<pre><code>     onThread:(NSThread *)thr
   withObject:(id)arg
waitUntilDone:(BOOL)wait
        modes:(NSArray *)array;
</code></pre><p>这个方法将创建一个 Source 0 任务，分发到指定线程的 RunLoop 中，在给定的 Mode 下执行，若指定的 RunLoop 处于休眠状态，则唤醒它处理事件，简单来说就是“睡你xx，起来嗨！”<br>于是，我们用一个可变数组装载当前所有需要“预缓存”的 index path，每个 RunLoopObserver 回调时都把第一个任务拿出来分发:</p>
</li>
</ul>
<p>NSMutableArray <em>mutableIndexPathsToBePrecached = self.fd<em>allIndexPathsToBePrecached.mutableCopy;<br>CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity </em>) {<br>    if (mutableIndexPathsToBePrecached.count == 0) {<br>        CFRunLoopRemoveObserver(runLoop, observer, runLoopMode);<br>        CFRelease(observer); // 注意释放，否则会造成内存泄露<br>        return;<br>    }<br>    NSIndexPath </em>indexPath = mutableIndexPathsToBePrecached.firstObject;<br>    [mutableIndexPathsToBePrecached removeObject:indexPath];<br>    [self performSelector:@selector(fd_precacheIndexPathIfNeeded:)<br>                 onThread:[NSThread mainThread]<br>               withObject:indexPath<br>            waitUntilDone:NO<br>                    modes:@[NSDefaultRunLoopMode]];<br>});<br>这样，每个任务都被分配到下个“空闲” RunLoop 迭代中执行，其间但凡有滑动事件开始，Mode 切换成 UITrackingRunLoopMode，所有的“预缓存”任务的分发和执行都会自动暂定，最大程度保证滑动流畅。</p>
<p>PS: 预缓存功能因为下拉刷新的冲突和不明显的收益已经废弃</p>
<p>#开始使用UITableView+FDTemplateLayoutCell</p>
<p>如果你觉得这个工具能帮得到你，整合到工程也十分简单。<br>使用 cocoapods：</p>
<p>pod search UITableView+FDTemplateLayoutCell</p>
<p>最后再复习下 github 地址： <a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/author.jpg"
               alt="Xu Chu" />
          <p class="site-author-name" itemprop="name">Xu Chu</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xu Chu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
